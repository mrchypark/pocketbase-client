// Code generated by pbc-gen. DO NOT EDIT.
// Any changes will be lost on next generation.

package main

import (
	"encoding/json"
	"fmt"

	"github.com/mrchypark/pocketbase-client"
	"github.com/pocketbase/pocketbase/tools/types"
)

// ==============
//  File Types
// ==============

// FileReference represents a file reference
type FileReference struct {
	filename   string
	recordID   string
	collection string
	fieldName  string
}

// Filename returns the filename
func (f FileReference) Filename() string {
	return f.filename
}

// URL generates the file URL
func (f FileReference) URL(baseURL string) string {
	if f.filename == "" {
		return ""
	}
	return fmt.Sprintf("%s/api/files/%s/%s/%s", baseURL, f.collection, f.recordID, f.filename)
}

// ThumbURL generates thumbnail URL
func (f FileReference) ThumbURL(baseURL, thumb string) string {
	if f.filename == "" {
		return ""
	}
	return fmt.Sprintf("%s/api/files/%s/%s/%s?thumb=%s", baseURL, f.collection, f.recordID, f.filename, thumb)
}

// IsEmpty returns true if the file reference is empty
func (f FileReference) IsEmpty() bool {
	return f.filename == ""
}

// NewFileReference creates a new FileReference
func NewFileReference(filename, recordID, collection, fieldName string) FileReference {
	return FileReference{
		filename:   filename,
		recordID:   recordID,
		collection: collection,
		fieldName:  fieldName,
	}
}

// FileReferences represents multiple file references
type FileReferences []FileReference

// Filenames returns all filenames
func (f FileReferences) Filenames() []string {
	names := make([]string, len(f))
	for i, file := range f {
		names[i] = file.Filename()
	}
	return names
}

// URLs generates URLs for all files
func (f FileReferences) URLs(baseURL string) []string {
	urls := make([]string, len(f))
	for i, file := range f {
		urls[i] = file.URL(baseURL)
	}
	return urls
}

// ThumbURLs generates thumbnail URLs for all files
func (f FileReferences) ThumbURLs(baseURL, thumb string) []string {
	urls := make([]string, len(f))
	for i, file := range f {
		urls[i] = file.ThumbURL(baseURL, thumb)
	}
	return urls
}

// IsEmpty returns true if there are no file references
func (f FileReferences) IsEmpty() bool {
	return len(f) == 0
}

// Filter returns non-empty file references
func (f FileReferences) Filter() FileReferences {
	var filtered FileReferences
	for _, file := range f {
		if !file.IsEmpty() {
			filtered = append(filtered, file)
		}
	}
	return filtered
}

// ==============
//  Collection Types
// ==============

// AllTypes represents a record from the 'all_types' collection.
type AllTypes struct {
	pocketbase.BaseModel

	TextRequired         string          `json:"text_required"`
	TextOptional         *string         `json:"text_optional,omitempty"`
	NumberRequired       float64         `json:"number_required"`
	NumberOptional       *float64        `json:"number_optional,omitempty"`
	BoolRequired         bool            `json:"bool_required"`
	BoolOptional         *bool           `json:"bool_optional,omitempty"`
	EmailRequired        string          `json:"email_required"`
	EmailOptional        *string         `json:"email_optional,omitempty"`
	URLRequired          string          `json:"url_required"`
	URLOptional          *string         `json:"url_optional,omitempty"`
	DateRequired         types.DateTime  `json:"date_required"`
	DateOptional         *types.DateTime `json:"date_optional,omitempty"`
	SelectSingleRequired string          `json:"select_single_required"`
	SelectSingleOptional *string         `json:"select_single_optional,omitempty"`
	SelectMultiRequired  []string        `json:"select_multi_required"`
	SelectMultiOptional  []string        `json:"select_multi_optional,omitempty"`
	JSONRequired         json.RawMessage `json:"json_required"`
	JSONOptional         json.RawMessage `json:"json_optional,omitempty"`
	FileSingle           *string         `json:"file_single,omitempty"`
	FileMulti            []string        `json:"file_multi,omitempty"`
	RelationSingle       *string         `json:"relation_single,omitempty"`
	RelationMulti        []string        `json:"relation_multi,omitempty"`
	Created              *types.DateTime `json:"created,omitempty"`
	Updated              *types.DateTime `json:"updated,omitempty"`
}

// RelatedCollection represents a record from the 'related_collection' collection.
type RelatedCollection struct {
	pocketbase.BaseModel

	Name string `json:"name"`
}

// ==============
//  Service Constructors (New Approach!)
// ==============

// NewAllTypesService creates a new typed service for AllTypes records.
// This is the recommended way to work with AllTypes records using the generic API.
func NewAllTypesService(client *pocketbase.Client) pocketbase.RecordServiceAPI[AllTypes] {
	return pocketbase.NewRecordService[AllTypes](client, "all_types")
}

// NewRelatedCollectionService creates a new typed service for RelatedCollection records.
// This is the recommended way to work with RelatedCollection records using the generic API.
func NewRelatedCollectionService(client *pocketbase.Client) pocketbase.RecordServiceAPI[RelatedCollection] {
	return pocketbase.NewRecordService[RelatedCollection](client, "related_collection")
}
