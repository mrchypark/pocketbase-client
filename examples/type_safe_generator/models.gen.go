// Code generated by pbc-gen. DO NOT EDIT.
// Any changes will be lost on next generation.

package main

import (
	"context"
	"fmt"

	"github.com/goccy/go-json"

	"github.com/mrchypark/pocketbase-client"
	"github.com/pocketbase/pocketbase/tools/types"
)

// ==============
//  File Types
// ==============

// FileReference represents a file reference
type FileReference struct {
	filename   string
	recordID   string
	collection string
	fieldName  string
}

// Filename returns the filename
func (f FileReference) Filename() string {
	return f.filename
}

// URL generates the file URL
func (f FileReference) URL(baseURL string) string {
	if f.filename == "" {
		return ""
	}
	return fmt.Sprintf("%s/api/files/%s/%s/%s", baseURL, f.collection, f.recordID, f.filename)
}

// ThumbURL generates thumbnail URL
func (f FileReference) ThumbURL(baseURL, thumb string) string {
	if f.filename == "" {
		return ""
	}
	return fmt.Sprintf("%s/api/files/%s/%s/%s?thumb=%s", baseURL, f.collection, f.recordID, f.filename, thumb)
}

// IsEmpty returns true if the file reference is empty
func (f FileReference) IsEmpty() bool {
	return f.filename == ""
}

// NewFileReference creates a new FileReference
func NewFileReference(filename, recordID, collection, fieldName string) FileReference {
	return FileReference{
		filename:   filename,
		recordID:   recordID,
		collection: collection,
		fieldName:  fieldName,
	}
}

// FileReferences represents multiple file references
type FileReferences []FileReference

// Filenames returns all filenames
func (f FileReferences) Filenames() []string {
	names := make([]string, len(f))
	for i, file := range f {
		names[i] = file.Filename()
	}
	return names
}

// URLs generates URLs for all files
func (f FileReferences) URLs(baseURL string) []string {
	urls := make([]string, len(f))
	for i, file := range f {
		urls[i] = file.URL(baseURL)
	}
	return urls
}

// ThumbURLs generates thumbnail URLs for all files
func (f FileReferences) ThumbURLs(baseURL, thumb string) []string {
	urls := make([]string, len(f))
	for i, file := range f {
		urls[i] = file.ThumbURL(baseURL, thumb)
	}
	return urls
}

// IsEmpty returns true if there are no file references
func (f FileReferences) IsEmpty() bool {
	return len(f) == 0
}

// Filter returns non-empty file references
func (f FileReferences) Filter() FileReferences {
	var filtered FileReferences
	for _, file := range f {
		if !file.IsEmpty() {
			filtered = append(filtered, file)
		}
	}
	return filtered
}

// ==============
//  Collection Types
// ==============

// AllTypes represents a record from the 'all_types' collection.
type AllTypes struct {
	// Latest schema: BaseModel only
	pocketbase.BaseModel
	TextRequired         string          `json:"text_required"`
	TextOptional         string          `json:"text_optional,omitempty"`
	NumberRequired       float64         `json:"number_required"`
	NumberOptional       float64         `json:"number_optional,omitempty"`
	BoolRequired         bool            `json:"bool_required"`
	BoolOptional         bool            `json:"bool_optional,omitempty"`
	EmailRequired        string          `json:"email_required"`
	EmailOptional        string          `json:"email_optional,omitempty"`
	URLRequired          string          `json:"url_required"`
	URLOptional          string          `json:"url_optional,omitempty"`
	DateRequired         types.DateTime  `json:"date_required"`
	DateOptional         types.DateTime  `json:"date_optional,omitempty"`
	SelectSingleRequired string          `json:"select_single_required"`
	SelectSingleOptional string          `json:"select_single_optional,omitempty"`
	SelectMultiRequired  []string        `json:"select_multi_required"`
	SelectMultiOptional  []string        `json:"select_multi_optional,omitempty"`
	JSONRequired         json.RawMessage `json:"json_required"`
	JSONOptional         json.RawMessage `json:"json_optional,omitempty"`
	FileSingle           string          `json:"file_single,omitempty"`
	FileMulti            []string        `json:"file_multi,omitempty"`
	RelationSingle       string          `json:"relation_single,omitempty"`
	RelationMulti        []string        `json:"relation_multi,omitempty"`
	Created              types.DateTime  `json:"created,omitempty"`
	Updated              types.DateTime  `json:"updated,omitempty"`
}

// AllTypesCollection is a collection of AllTypes records.
type AllTypesCollection struct {
	*pocketbase.ListResult
	Items []*AllTypes `json:"items"`
}

// NewAllTypes creates a new instance of AllTypes.
func NewAllTypes() *AllTypes {
	// Latest schema initialization
	return &AllTypes{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "pbc_all_types_123",
			CollectionName: "all_types",
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *AllTypes) ToMap() map[string]any {
	data := make(map[string]any)

	// Field data
	// For required fields, we always include them.
	data["text_required"] = m.TextRequired
	if m.TextOptional != "" {
		data["text_optional"] = m.TextOptional
	}
	// For required fields, we always include them.
	data["number_required"] = m.NumberRequired
	if m.NumberOptional != 0 {
		data["number_optional"] = m.NumberOptional
	}
	// For required fields, we always include them.
	data["bool_required"] = m.BoolRequired
	// Always include boolean fields
	data["bool_optional"] = m.BoolOptional
	// For required fields, we always include them.
	data["email_required"] = m.EmailRequired
	if m.EmailOptional != "" {
		data["email_optional"] = m.EmailOptional
	}
	// For required fields, we always include them.
	data["url_required"] = m.URLRequired
	if m.URLOptional != "" {
		data["url_optional"] = m.URLOptional
	}
	// For required fields, we always include them.
	data["date_required"] = m.DateRequired
	// Generic zero-value check for DateOptional
	{
		var zero11 types.DateTime
		if m.DateOptional != zero11 {
			data["date_optional"] = m.DateOptional
		}
	}
	// For required fields, we always include them.
	data["select_single_required"] = m.SelectSingleRequired
	if m.SelectSingleOptional != "" {
		data["select_single_optional"] = m.SelectSingleOptional
	}
	// For required fields, we always include them.
	data["select_multi_required"] = m.SelectMultiRequired
	if len(m.SelectMultiOptional) > 0 {
		data["select_multi_optional"] = m.SelectMultiOptional
	}
	// For required fields, we always include them.
	data["json_required"] = m.JSONRequired
	if len(m.JSONOptional) > 0 {
		data["json_optional"] = m.JSONOptional
	}
	if m.FileSingle != "" {
		data["file_single"] = m.FileSingle
	}
	if len(m.FileMulti) > 0 {
		data["file_multi"] = m.FileMulti
	}
	if m.RelationSingle != "" {
		data["relation_single"] = m.RelationSingle
	}
	if len(m.RelationMulti) > 0 {
		data["relation_multi"] = m.RelationMulti
	}
	// Generic zero-value check for Created
	{
		var zero22 types.DateTime
		if m.Created != zero22 {
			data["created"] = m.Created
		}
	}
	// Generic zero-value check for Updated
	{
		var zero23 types.DateTime
		if m.Updated != zero23 {
			data["updated"] = m.Updated
		}
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// RelatedCollection represents a record from the 'related_collection' collection.
type RelatedCollection struct {
	// Latest schema: BaseModel only
	pocketbase.BaseModel
	Name string `json:"name"`
}

// RelatedCollectionCollection is a collection of RelatedCollection records.
type RelatedCollectionCollection struct {
	*pocketbase.ListResult
	Items []*RelatedCollection `json:"items"`
}

// NewRelatedCollection creates a new instance of RelatedCollection.
func NewRelatedCollection() *RelatedCollection {
	// Latest schema initialization
	return &RelatedCollection{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "pbc_1125843985",
			CollectionName: "related_collection",
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *RelatedCollection) ToMap() map[string]any {
	data := make(map[string]any)

	// Field data
	// For required fields, we always include them.
	data["name"] = m.Name

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// ==============
//  Service Constructors (Generic)
// ==============

// NewAllTypesService creates a new generic service for all_types collection.
func NewAllTypesService(client *pocketbase.Client) *pocketbase.Service[*AllTypes] {
	return pocketbase.NewService[*AllTypes](
		client,
		"all_types",
		NewAllTypes,
	)
}

// NewRelatedCollectionService creates a new generic service for related_collection collection.
func NewRelatedCollectionService(client *pocketbase.Client) *pocketbase.Service[*RelatedCollection] {
	return pocketbase.NewService[*RelatedCollection](
		client,
		"related_collection",
		NewRelatedCollection,
	)
}

// ==============
//  Convenience Functions (Backward Compatibility)
// ==============

// GetAllTypes fetches a single AllTypes record by its ID.
// Deprecated: Use AllTypesService.GetOne instead.
func GetAllTypes(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*AllTypes, error) {

	service := NewAllTypesService(client)
	return service.GetOne(context.Background(), id, opts)

}

// GetAllTypesList fetches a list of AllTypes records.
// Deprecated: Use AllTypesService.GetList instead.
func GetAllTypesList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*AllTypesCollection, error) {

	service := NewAllTypesService(client)
	result, err := service.GetList(context.Background(), opts)
	if err != nil {
		return nil, err
	}
	// Convert generic result to legacy collection format
	return &AllTypesCollection{
		ListResult: result.ListResult,
		Items:      result.Items,
	}, nil

}

// GetRelatedCollection fetches a single RelatedCollection record by its ID.
// Deprecated: Use RelatedCollectionService.GetOne instead.
func GetRelatedCollection(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*RelatedCollection, error) {

	service := NewRelatedCollectionService(client)
	return service.GetOne(context.Background(), id, opts)

}

// GetRelatedCollectionList fetches a list of RelatedCollection records.
// Deprecated: Use RelatedCollectionService.GetList instead.
func GetRelatedCollectionList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*RelatedCollectionCollection, error) {

	service := NewRelatedCollectionService(client)
	result, err := service.GetList(context.Background(), opts)
	if err != nil {
		return nil, err
	}
	// Convert generic result to legacy collection format
	return &RelatedCollectionCollection{
		ListResult: result.ListResult,
		Items:      result.Items,
	}, nil

}
