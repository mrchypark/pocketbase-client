// Code generated by pbc-gen. DO NOT EDIT.
// Any changes will be lost on next generation.

package main

import (
	"context"

	"github.com/mrchypark/pocketbase-client"
	"github.com/pocketbase/pocketbase/tools/types"
)

// ==============
//  Collection Types
// ==============

// Superusers represents a record from the '_superusers' collection.
type Superusers struct {
	pocketbase.Record
}

// SuperusersCollection is a collection of Superusers records.
type SuperusersCollection struct {
	*pocketbase.ListResult
	Items []*Superusers `json:"items"`
}

// NewSuperusers creates a new instance of Superusers.
func NewSuperusers() *Superusers {
	return &Superusers{Record: pocketbase.Record{}}
}

// ToSuperusers creates a new instance of Superusers with the provided record.
func ToSuperusers(r *pocketbase.Record) *Superusers {
	return &Superusers{Record: *r}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Superusers) ToMap() map[string]any {
	data := make(map[string]interface{})

	// non-zero, non-empty, and non-nil values will be added to the map.

	return data
}

// Users represents a record from the 'users' collection.
type Users struct {
	pocketbase.Record
}

// UsersCollection is a collection of Users records.
type UsersCollection struct {
	*pocketbase.ListResult
	Items []*Users `json:"items"`
}

// NewUsers creates a new instance of Users.
func NewUsers() *Users {
	return &Users{Record: pocketbase.Record{}}
}

// ToUsers creates a new instance of Users with the provided record.
func ToUsers(r *pocketbase.Record) *Users {
	return &Users{Record: *r}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Users) ToMap() map[string]any {
	data := make(map[string]interface{})

	// non-zero, non-empty, and non-nil values will be added to the map.
	if val := m.Name(); val != nil {
		data["name"] = *val // Dereference pointer
	}
	if val := m.Avatar(); len(val) > 0 {
		data["avatar"] = val
	}
	if val := m.Created(); val != nil {
		data["created"] = *val // Dereference pointer
	}
	if val := m.Updated(); val != nil {
		data["updated"] = *val // Dereference pointer
	}

	return data
}

// Name returns the value of the 'name' field.
func (m *Users) Name() *string {
	return m.GetStringPointer("name")
}

// SetName sets the value of the 'name' field.
func (m *Users) SetName(value *string) {
	if value != nil {
		m.Set("name", *value) // ✨ 수정: 포인터를 역참조하여 실제 값을 저장
	} else {
		m.Set("name", nil)
	}
}

// Avatar returns the value of the 'avatar' field.
func (m *Users) Avatar() []string {
	return m.GetStringSlice("avatar")
}

// SetAvatar sets the value of the 'avatar' field.
func (m *Users) SetAvatar(value []string) {
	m.Set("avatar", value)
}

// Created returns the value of the 'created' field.
func (m *Users) Created() *types.DateTime {
	return m.GetDateTimePointer("created")
}

// SetCreated sets the value of the 'created' field.
func (m *Users) SetCreated(value *types.DateTime) {
	if value != nil {
		m.Set("created", *value) // ✨ 수정: 포인터를 역참조하여 실제 값을 저장
	} else {
		m.Set("created", nil)
	}
}

// Updated returns the value of the 'updated' field.
func (m *Users) Updated() *types.DateTime {
	return m.GetDateTimePointer("updated")
}

// SetUpdated sets the value of the 'updated' field.
func (m *Users) SetUpdated(value *types.DateTime) {
	if value != nil {
		m.Set("updated", *value) // ✨ 수정: 포인터를 역참조하여 실제 값을 저장
	} else {
		m.Set("updated", nil)
	}
}

// Posts represents a record from the 'posts' collection.
type Posts struct {
	pocketbase.Record
}

// PostsCollection is a collection of Posts records.
type PostsCollection struct {
	*pocketbase.ListResult
	Items []*Posts `json:"items"`
}

// NewPosts creates a new instance of Posts.
func NewPosts() *Posts {
	return &Posts{Record: pocketbase.Record{}}
}

// ToPosts creates a new instance of Posts with the provided record.
func ToPosts(r *pocketbase.Record) *Posts {
	return &Posts{Record: *r}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Posts) ToMap() map[string]any {
	data := make(map[string]interface{})

	// non-zero, non-empty, and non-nil values will be added to the map.
	if val := m.Title(); val != nil {
		data["title"] = *val // Dereference pointer
	}
	if val := m.Created(); val != nil {
		data["created"] = *val // Dereference pointer
	}
	if val := m.Updated(); val != nil {
		data["updated"] = *val // Dereference pointer
	}

	return data
}

// Title returns the value of the 'title' field.
func (m *Posts) Title() *string {
	return m.GetStringPointer("title")
}

// SetTitle sets the value of the 'title' field.
func (m *Posts) SetTitle(value *string) {
	if value != nil {
		m.Set("title", *value) // ✨ 수정: 포인터를 역참조하여 실제 값을 저장
	} else {
		m.Set("title", nil)
	}
}

// Created returns the value of the 'created' field.
func (m *Posts) Created() *types.DateTime {
	return m.GetDateTimePointer("created")
}

// SetCreated sets the value of the 'created' field.
func (m *Posts) SetCreated(value *types.DateTime) {
	if value != nil {
		m.Set("created", *value) // ✨ 수정: 포인터를 역참조하여 실제 값을 저장
	} else {
		m.Set("created", nil)
	}
}

// Updated returns the value of the 'updated' field.
func (m *Posts) Updated() *types.DateTime {
	return m.GetDateTimePointer("updated")
}

// SetUpdated sets the value of the 'updated' field.
func (m *Posts) SetUpdated(value *types.DateTime) {
	if value != nil {
		m.Set("updated", *value) // ✨ 수정: 포인터를 역참조하여 실제 값을 저장
	} else {
		m.Set("updated", nil)
	}
}

// ==============
//  Typed Helpers
// ==============

// GetSuperusers fetches a single Superusers record by its ID.
func GetSuperusers(client pocketbase.RecordServiceAPI, id string, opts *pocketbase.GetOneOptions) (*Superusers, error) {
	r, err := client.GetOne(context.Background(), "_superusers", id, opts)
	if err != nil {
		return nil, err
	}
	return ToSuperusers(r), nil
}

// GetSuperusersList fetches a list of Superusers records.
func GetSuperusersList(client pocketbase.RecordServiceAPI, opts *pocketbase.ListOptions) (*SuperusersCollection, error) {
	listResult, err := client.GetList(context.Background(), "_superusers", opts)
	if err != nil {
		return nil, err
	}

	typedItems := make([]*Superusers, len(listResult.Items))
	for i, r := range listResult.Items {
		typedItems[i] = ToSuperusers(r)
	}

	return &SuperusersCollection{
		ListResult: listResult,
		Items:      typedItems,
	}, nil
}

// GetUsers fetches a single Users record by its ID.
func GetUsers(client pocketbase.RecordServiceAPI, id string, opts *pocketbase.GetOneOptions) (*Users, error) {
	r, err := client.GetOne(context.Background(), "users", id, opts)
	if err != nil {
		return nil, err
	}
	return ToUsers(r), nil
}

// GetUsersList fetches a list of Users records.
func GetUsersList(client pocketbase.RecordServiceAPI, opts *pocketbase.ListOptions) (*UsersCollection, error) {
	listResult, err := client.GetList(context.Background(), "users", opts)
	if err != nil {
		return nil, err
	}

	typedItems := make([]*Users, len(listResult.Items))
	for i, r := range listResult.Items {
		typedItems[i] = ToUsers(r)
	}

	return &UsersCollection{
		ListResult: listResult,
		Items:      typedItems,
	}, nil
}

// GetPosts fetches a single Posts record by its ID.
func GetPosts(client pocketbase.RecordServiceAPI, id string, opts *pocketbase.GetOneOptions) (*Posts, error) {
	r, err := client.GetOne(context.Background(), "posts", id, opts)
	if err != nil {
		return nil, err
	}
	return ToPosts(r), nil
}

// GetPostsList fetches a list of Posts records.
func GetPostsList(client pocketbase.RecordServiceAPI, opts *pocketbase.ListOptions) (*PostsCollection, error) {
	listResult, err := client.GetList(context.Background(), "posts", opts)
	if err != nil {
		return nil, err
	}

	typedItems := make([]*Posts, len(listResult.Items))
	for i, r := range listResult.Items {
		typedItems[i] = ToPosts(r)
	}

	return &PostsCollection{
		ListResult: listResult,
		Items:      typedItems,
	}, nil
}
