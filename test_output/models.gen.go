// Code generated by pbc-gen. DO NOT EDIT.
// Any changes will be lost on next generation.

package models

import (
	"context"
	"fmt"
	"net/url"

	"github.com/goccy/go-json"

	"github.com/mrchypark/pocketbase-client"
	"github.com/pocketbase/pocketbase/tools/types"
)

// ==============
//  Enum Constants
// ==============

// DevicesTypeType enum constants for devices.type
const (
	DevicesTypeM2 = "m2"
	DevicesTypeD2 = "d2"
	DevicesTypeS2 = "s2"
)

// DevicesTypeTypeValues returns all possible values for DevicesTypeType
func DevicesTypeTypeValues() []string {
	return []string{
		DevicesTypeM2,
		DevicesTypeD2,
		DevicesTypeS2,
	}
}

// IsValidDevicesTypeType checks if the given value is a valid DevicesTypeType
func IsValidDevicesTypeType(value string) bool {
	switch value {
	case DevicesTypeM2:
		return true
	case DevicesTypeD2:
		return true
	case DevicesTypeS2:
		return true
	default:
		return false
	}
}

// ==============
//  Relation Types
// ==============

// OrganizationsRelation represents a relation to organizations collection
type OrganizationsRelation struct {
	id string
}

// ID returns the relation ID
func (r OrganizationsRelation) ID() string {
	return r.id
}

// Load fetches the related Organizations record
func (r OrganizationsRelation) Load(ctx context.Context, client pocketbase.RecordServiceAPI) (*Organizations, error) {
	if r.id == "" {
		return nil, nil
	}
	return GetOrganizations(client, r.id, nil)
}

// IsEmpty returns true if the relation is empty
func (r OrganizationsRelation) IsEmpty() bool {
	return r.id == ""
}

// NewOrganizationsRelation creates a new OrganizationsRelation
func NewOrganizationsRelation(id string) OrganizationsRelation {
	return OrganizationsRelation{id: id}
}

// WorkOrdersRelation represents a relation to work_orders collection
type WorkOrdersRelation struct {
	id string
}

// ID returns the relation ID
func (r WorkOrdersRelation) ID() string {
	return r.id
}

// Load fetches the related WorkOrders record
func (r WorkOrdersRelation) Load(ctx context.Context, client pocketbase.RecordServiceAPI) (*WorkOrders, error) {
	if r.id == "" {
		return nil, nil
	}
	return GetWorkOrders(client, r.id, nil)
}

// IsEmpty returns true if the relation is empty
func (r WorkOrdersRelation) IsEmpty() bool {
	return r.id == ""
}

// NewWorkOrdersRelation creates a new WorkOrdersRelation
func NewWorkOrdersRelation(id string) WorkOrdersRelation {
	return WorkOrdersRelation{id: id}
}

// UsersRelation represents a relation to users collection
type UsersRelation struct {
	id string
}

// ID returns the relation ID
func (r UsersRelation) ID() string {
	return r.id
}

// Load fetches the related Users record
func (r UsersRelation) Load(ctx context.Context, client pocketbase.RecordServiceAPI) (*Users, error) {
	if r.id == "" {
		return nil, nil
	}
	return GetUsers(client, r.id, nil)
}

// IsEmpty returns true if the relation is empty
func (r UsersRelation) IsEmpty() bool {
	return r.id == ""
}

// NewUsersRelation creates a new UsersRelation
func NewUsersRelation(id string) UsersRelation {
	return UsersRelation{id: id}
}

// PlantsRelation represents a relation to plants collection
type PlantsRelation struct {
	id string
}

// ID returns the relation ID
func (r PlantsRelation) ID() string {
	return r.id
}

// Load fetches the related Plants record
func (r PlantsRelation) Load(ctx context.Context, client pocketbase.RecordServiceAPI) (*Plants, error) {
	if r.id == "" {
		return nil, nil
	}
	return GetPlants(client, r.id, nil)
}

// IsEmpty returns true if the relation is empty
func (r PlantsRelation) IsEmpty() bool {
	return r.id == ""
}

// NewPlantsRelation creates a new PlantsRelation
func NewPlantsRelation(id string) PlantsRelation {
	return PlantsRelation{id: id}
}

// ImagesRelation represents a relation to images collection
type ImagesRelation struct {
	id string
}

// ID returns the relation ID
func (r ImagesRelation) ID() string {
	return r.id
}

// Load fetches the related Images record
func (r ImagesRelation) Load(ctx context.Context, client pocketbase.RecordServiceAPI) (*Images, error) {
	if r.id == "" {
		return nil, nil
	}
	return GetImages(client, r.id, nil)
}

// IsEmpty returns true if the relation is empty
func (r ImagesRelation) IsEmpty() bool {
	return r.id == ""
}

// NewImagesRelation creates a new ImagesRelation
func NewImagesRelation(id string) ImagesRelation {
	return ImagesRelation{id: id}
}

// CommentsRelation represents a relation to comments collection
type CommentsRelation struct {
	id string
}

// ID returns the relation ID
func (r CommentsRelation) ID() string {
	return r.id
}

// Load fetches the related Comments record
func (r CommentsRelation) Load(ctx context.Context, client pocketbase.RecordServiceAPI) (*Comments, error) {
	if r.id == "" {
		return nil, nil
	}
	return GetComments(client, r.id, nil)
}

// IsEmpty returns true if the relation is empty
func (r CommentsRelation) IsEmpty() bool {
	return r.id == ""
}

// NewCommentsRelation creates a new CommentsRelation
func NewCommentsRelation(id string) CommentsRelation {
	return CommentsRelation{id: id}
}

// FactoriesRelation represents a relation to factories collection
type FactoriesRelation struct {
	id string
}

// ID returns the relation ID
func (r FactoriesRelation) ID() string {
	return r.id
}

// Load fetches the related Factories record
func (r FactoriesRelation) Load(ctx context.Context, client pocketbase.RecordServiceAPI) (*Factories, error) {
	if r.id == "" {
		return nil, nil
	}
	return GetFactories(client, r.id, nil)
}

// IsEmpty returns true if the relation is empty
func (r FactoriesRelation) IsEmpty() bool {
	return r.id == ""
}

// NewFactoriesRelation creates a new FactoriesRelation
func NewFactoriesRelation(id string) FactoriesRelation {
	return FactoriesRelation{id: id}
}

// IssuesRelation represents a relation to issues collection
type IssuesRelation struct {
	id string
}

// ID returns the relation ID
func (r IssuesRelation) ID() string {
	return r.id
}

// Load fetches the related Issues record
func (r IssuesRelation) Load(ctx context.Context, client pocketbase.RecordServiceAPI) (*Issues, error) {
	if r.id == "" {
		return nil, nil
	}
	return GetIssues(client, r.id, nil)
}

// IsEmpty returns true if the relation is empty
func (r IssuesRelation) IsEmpty() bool {
	return r.id == ""
}

// NewIssuesRelation creates a new IssuesRelation
func NewIssuesRelation(id string) IssuesRelation {
	return IssuesRelation{id: id}
}

// IssueTagsRelation represents a relation to issue_tags collection
type IssueTagsRelation struct {
	id string
}

// ID returns the relation ID
func (r IssueTagsRelation) ID() string {
	return r.id
}

// Load fetches the related IssueTags record
func (r IssueTagsRelation) Load(ctx context.Context, client pocketbase.RecordServiceAPI) (*IssueTags, error) {
	if r.id == "" {
		return nil, nil
	}
	return GetIssueTags(client, r.id, nil)
}

// IsEmpty returns true if the relation is empty
func (r IssueTagsRelation) IsEmpty() bool {
	return r.id == ""
}

// NewIssueTagsRelation creates a new IssueTagsRelation
func NewIssueTagsRelation(id string) IssueTagsRelation {
	return IssueTagsRelation{id: id}
}

// ViewersRelation represents a relation to viewers collection
type ViewersRelation struct {
	id string
}

// ID returns the relation ID
func (r ViewersRelation) ID() string {
	return r.id
}

// Load fetches the related Viewers record
func (r ViewersRelation) Load(ctx context.Context, client pocketbase.RecordServiceAPI) (*Viewers, error) {
	if r.id == "" {
		return nil, nil
	}
	return GetViewers(client, r.id, nil)
}

// IsEmpty returns true if the relation is empty
func (r ViewersRelation) IsEmpty() bool {
	return r.id == ""
}

// NewViewersRelation creates a new ViewersRelation
func NewViewersRelation(id string) ViewersRelation {
	return ViewersRelation{id: id}
}

// TemporaryAccountsRelation represents a relation to temporary_accounts collection
type TemporaryAccountsRelation struct {
	id string
}

// ID returns the relation ID
func (r TemporaryAccountsRelation) ID() string {
	return r.id
}

// Load fetches the related TemporaryAccounts record
func (r TemporaryAccountsRelation) Load(ctx context.Context, client pocketbase.RecordServiceAPI) (*TemporaryAccounts, error) {
	if r.id == "" {
		return nil, nil
	}
	return GetTemporaryAccounts(client, r.id, nil)
}

// IsEmpty returns true if the relation is empty
func (r TemporaryAccountsRelation) IsEmpty() bool {
	return r.id == ""
}

// NewTemporaryAccountsRelation creates a new TemporaryAccountsRelation
func NewTemporaryAccountsRelation(id string) TemporaryAccountsRelation {
	return TemporaryAccountsRelation{id: id}
}

// PermissionsRelation represents a relation to permissions collection
type PermissionsRelation struct {
	id string
}

// ID returns the relation ID
func (r PermissionsRelation) ID() string {
	return r.id
}

// Load fetches the related Permissions record
func (r PermissionsRelation) Load(ctx context.Context, client pocketbase.RecordServiceAPI) (*Permissions, error) {
	if r.id == "" {
		return nil, nil
	}
	return GetPermissions(client, r.id, nil)
}

// IsEmpty returns true if the relation is empty
func (r PermissionsRelation) IsEmpty() bool {
	return r.id == ""
}

// NewPermissionsRelation creates a new PermissionsRelation
func NewPermissionsRelation(id string) PermissionsRelation {
	return PermissionsRelation{id: id}
}

// ==============
//  File Types
// ==============

// FileReference represents a file reference
type FileReference struct {
	filename   string
	recordID   string
	collection string
	fieldName  string
}

// Filename returns the filename
func (f FileReference) Filename() string {
	return f.filename
}

// URL generates the file URL
func (f FileReference) URL(baseURL string) string {
	if f.filename == "" {
		return ""
	}
	return fmt.Sprintf("%s/api/files/%s/%s/%s", baseURL, f.collection, f.recordID, f.filename)
}

// ThumbURL generates thumbnail URL
func (f FileReference) ThumbURL(baseURL, thumb string) string {
	if f.filename == "" {
		return ""
	}
	return fmt.Sprintf("%s/api/files/%s/%s/%s?thumb=%s", baseURL, f.collection, f.recordID, f.filename, thumb)
}

// IsEmpty returns true if the file reference is empty
func (f FileReference) IsEmpty() bool {
	return f.filename == ""
}

// NewFileReference creates a new FileReference
func NewFileReference(filename, recordID, collection, fieldName string) FileReference {
	return FileReference{
		filename:   filename,
		recordID:   recordID,
		collection: collection,
		fieldName:  fieldName,
	}
}

// FileReferences represents multiple file references
type FileReferences []FileReference

// Filenames returns all filenames
func (f FileReferences) Filenames() []string {
	names := make([]string, len(f))
	for i, file := range f {
		names[i] = file.Filename()
	}
	return names
}

// URLs generates URLs for all files
func (f FileReferences) URLs(baseURL string) []string {
	urls := make([]string, len(f))
	for i, file := range f {
		urls[i] = file.URL(baseURL)
	}
	return urls
}

// ThumbURLs generates thumbnail URLs for all files
func (f FileReferences) ThumbURLs(baseURL, thumb string) []string {
	urls := make([]string, len(f))
	for i, file := range f {
		urls[i] = file.ThumbURL(baseURL, thumb)
	}
	return urls
}

// IsEmpty returns true if there are no file references
func (f FileReferences) IsEmpty() bool {
	return len(f) == 0
}

// Filter returns non-empty file references
func (f FileReferences) Filter() FileReferences {
	var filtered FileReferences
	for _, file := range f {
		if !file.IsEmpty() {
			filtered = append(filtered, file)
		}
	}
	return filtered
}

// ==============
//  Collection Types
// ==============

// TemporaryAccounts represents a record from the 'temporary_accounts' collection.
type TemporaryAccounts struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Organization string          `json:"organization"`
	Link         string          `json:"link"`
	Expired      *types.DateTime `json:"expired",omitempty`
	WorkOrder    *string         `json:"work_order",omitempty`
}

// TemporaryAccountsCollection is a collection of TemporaryAccounts records.
type TemporaryAccountsCollection struct {
	*pocketbase.ListResult
	Items []*TemporaryAccounts `json:"items"`
}

// NewTemporaryAccounts creates a new instance of TemporaryAccounts.
func NewTemporaryAccounts() *TemporaryAccounts {
	// Legacy schema initialization
	return &TemporaryAccounts{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "temporary_accounts",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *TemporaryAccounts) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["organization"] = m.Organization
	// For required fields, we always include them.
	data["link"] = m.Link
	if m.Expired != nil {
		data["expired"] = m.Expired
	}
	if m.WorkOrder != nil {
		data["work_order"] = m.WorkOrder
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *TemporaryAccounts) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *TemporaryAccounts) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *TemporaryAccounts) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *TemporaryAccounts) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *TemporaryAccounts) GetUpdated() types.DateTime {
	return m.Updated
}

// Users represents a record from the 'users' collection.
type Users struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Organizations []string        `json:"organizations",omitempty`
	Name          *string         `json:"name",omitempty`
	Metadata      json.RawMessage `json:"metadata",omitempty`
}

// UsersCollection is a collection of Users records.
type UsersCollection struct {
	*pocketbase.ListResult
	Items []*Users `json:"items"`
}

// NewUsers creates a new instance of Users.
func NewUsers() *Users {
	// Legacy schema initialization
	return &Users{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "users",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Users) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	if len(m.Organizations) > 0 {
		data["organizations"] = m.Organizations
	}
	if m.Name != nil {
		data["name"] = m.Name
	}
	// Generic zero-value check
	var zero json.RawMessage
	if m.Metadata != zero {
		data["metadata"] = m.Metadata
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Users) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Users) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Users) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Users) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Users) GetUpdated() types.DateTime {
	return m.Updated
}

// Viewers represents a record from the 'viewers' collection.
type Viewers struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Organizations []string `json:"organizations",omitempty`
	Name          string   `json:"name"`
}

// ViewersCollection is a collection of Viewers records.
type ViewersCollection struct {
	*pocketbase.ListResult
	Items []*Viewers `json:"items"`
}

// NewViewers creates a new instance of Viewers.
func NewViewers() *Viewers {
	// Legacy schema initialization
	return &Viewers{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "viewers",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Viewers) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	if len(m.Organizations) > 0 {
		data["organizations"] = m.Organizations
	}
	// For required fields, we always include them.
	data["name"] = m.Name

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Viewers) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Viewers) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Viewers) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Viewers) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Viewers) GetUpdated() types.DateTime {
	return m.Updated
}

// CommandHistory represents a record from the 'command_history' collection.
type CommandHistory struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Sender  string          `json:"sender"`
	Plant   string          `json:"plant"`
	Command json.RawMessage `json:"command"`
}

// CommandHistoryCollection is a collection of CommandHistory records.
type CommandHistoryCollection struct {
	*pocketbase.ListResult
	Items []*CommandHistory `json:"items"`
}

// NewCommandHistory creates a new instance of CommandHistory.
func NewCommandHistory() *CommandHistory {
	// Legacy schema initialization
	return &CommandHistory{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "command_history",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *CommandHistory) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["sender"] = m.Sender
	// For required fields, we always include them.
	data["plant"] = m.Plant
	// For required fields, we always include them.
	data["command"] = m.Command

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *CommandHistory) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *CommandHistory) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *CommandHistory) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *CommandHistory) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *CommandHistory) GetUpdated() types.DateTime {
	return m.Updated
}

// Comments represents a record from the 'comments' collection.
type Comments struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Plant     string          `json:"plant"`
	User      string          `json:"user"`
	Title     *string         `json:"title",omitempty`
	Text      *string         `json:"text",omitempty`
	Images    []string        `json:"images",omitempty`
	Tag       json.RawMessage `json:"tag",omitempty`
	Parent    *string         `json:"parent",omitempty`
	Resolved  *types.DateTime `json:"resolved",omitempty`
	Related   *types.DateTime `json:"related",omitempty`
	IsPrivate *bool           `json:"isPrivate",omitempty`
	IsArchive *bool           `json:"isArchive",omitempty`
}

// CommentsCollection is a collection of Comments records.
type CommentsCollection struct {
	*pocketbase.ListResult
	Items []*Comments `json:"items"`
}

// NewComments creates a new instance of Comments.
func NewComments() *Comments {
	// Legacy schema initialization
	return &Comments{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "comments",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Comments) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["plant"] = m.Plant
	// For required fields, we always include them.
	data["user"] = m.User
	if m.Title != nil {
		data["title"] = m.Title
	}
	if m.Text != nil {
		data["text"] = m.Text
	}
	if len(m.Images) > 0 {
		data["images"] = m.Images
	}
	// Generic zero-value check
	var zero json.RawMessage
	if m.Tag != zero {
		data["tag"] = m.Tag
	}
	if m.Parent != nil {
		data["parent"] = m.Parent
	}
	if m.Resolved != nil {
		data["resolved"] = m.Resolved
	}
	if m.Related != nil {
		data["related"] = m.Related
	}
	if m.IsPrivate != nil {
		data["isPrivate"] = m.IsPrivate
	}
	if m.IsArchive != nil {
		data["isArchive"] = m.IsArchive
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Comments) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Comments) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Comments) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Comments) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Comments) GetUpdated() types.DateTime {
	return m.Updated
}

// Dashboard represents a record from the 'dashboard' collection.
type Dashboard struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Plant string          `json:"plant"`
	Data  json.RawMessage `json:"data",omitempty`
}

// DashboardCollection is a collection of Dashboard records.
type DashboardCollection struct {
	*pocketbase.ListResult
	Items []*Dashboard `json:"items"`
}

// NewDashboard creates a new instance of Dashboard.
func NewDashboard() *Dashboard {
	// Legacy schema initialization
	return &Dashboard{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "dashboard",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Dashboard) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["plant"] = m.Plant
	// Generic zero-value check
	var zero json.RawMessage
	if m.Data != zero {
		data["data"] = m.Data
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Dashboard) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Dashboard) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Dashboard) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Dashboard) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Dashboard) GetUpdated() types.DateTime {
	return m.Updated
}

// Devices represents a record from the 'devices' collection.
type Devices struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	DeviceId  string          `json:"deviceId"`
	Factories []string        `json:"factories"`
	Status    string          `json:"status"`
	Location  json.RawMessage `json:"location"`
	Tag       json.RawMessage `json:"tag",omitempty`
	Plant     *string         `json:"plant",omitempty`
	PanelId   *string         `json:"panelId",omitempty`
	Type      *string         `json:"type",omitempty`
}

// DevicesCollection is a collection of Devices records.
type DevicesCollection struct {
	*pocketbase.ListResult
	Items []*Devices `json:"items"`
}

// NewDevices creates a new instance of Devices.
func NewDevices() *Devices {
	// Legacy schema initialization
	return &Devices{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "devices",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Devices) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["deviceId"] = m.DeviceId
	// For required fields, we always include them.
	data["factories"] = m.Factories
	// For required fields, we always include them.
	data["status"] = m.Status
	// For required fields, we always include them.
	data["location"] = m.Location
	// Generic zero-value check
	var zero json.RawMessage
	if m.Tag != zero {
		data["tag"] = m.Tag
	}
	if m.Plant != nil {
		data["plant"] = m.Plant
	}
	if m.PanelId != nil {
		data["panelId"] = m.PanelId
	}
	if m.Type != nil {
		data["type"] = m.Type
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Devices) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Devices) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Devices) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Devices) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Devices) GetUpdated() types.DateTime {
	return m.Updated
}

// Factories represents a record from the 'factories' collection.
type Factories struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Name *string `json:"name",omitempty`
	Role *string `json:"role",omitempty`
}

// FactoriesCollection is a collection of Factories records.
type FactoriesCollection struct {
	*pocketbase.ListResult
	Items []*Factories `json:"items"`
}

// NewFactories creates a new instance of Factories.
func NewFactories() *Factories {
	// Legacy schema initialization
	return &Factories{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "factories",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Factories) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	if m.Name != nil {
		data["name"] = m.Name
	}
	if m.Role != nil {
		data["role"] = m.Role
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Factories) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Factories) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Factories) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Factories) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Factories) GetUpdated() types.DateTime {
	return m.Updated
}

// Groupconditions represents a record from the 'groupconditions' collection.
type Groupconditions struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Plant      string          `json:"plant"`
	Name       string          `json:"name"`
	Conditions json.RawMessage `json:"conditions",omitempty`
}

// GroupconditionsCollection is a collection of Groupconditions records.
type GroupconditionsCollection struct {
	*pocketbase.ListResult
	Items []*Groupconditions `json:"items"`
}

// NewGroupconditions creates a new instance of Groupconditions.
func NewGroupconditions() *Groupconditions {
	// Legacy schema initialization
	return &Groupconditions{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "groupconditions",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Groupconditions) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["plant"] = m.Plant
	// For required fields, we always include them.
	data["name"] = m.Name
	// Generic zero-value check
	var zero json.RawMessage
	if m.Conditions != zero {
		data["conditions"] = m.Conditions
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Groupconditions) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Groupconditions) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Groupconditions) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Groupconditions) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Groupconditions) GetUpdated() types.DateTime {
	return m.Updated
}

// Images represents a record from the 'images' collection.
type Images struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Image string `json:"image"`
}

// ImagesCollection is a collection of Images records.
type ImagesCollection struct {
	*pocketbase.ListResult
	Items []*Images `json:"items"`
}

// NewImages creates a new instance of Images.
func NewImages() *Images {
	// Legacy schema initialization
	return &Images{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "images",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Images) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["image"] = m.Image

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Images) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Images) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Images) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Images) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Images) GetUpdated() types.DateTime {
	return m.Updated
}

// Invitations represents a record from the 'invitations' collection.
type Invitations struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Organization string `json:"organization"`
	Email        string `json:"email"`
	IsUsed       *bool  `json:"isUsed",omitempty`
}

// InvitationsCollection is a collection of Invitations records.
type InvitationsCollection struct {
	*pocketbase.ListResult
	Items []*Invitations `json:"items"`
}

// NewInvitations creates a new instance of Invitations.
func NewInvitations() *Invitations {
	// Legacy schema initialization
	return &Invitations{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "invitations",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Invitations) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["organization"] = m.Organization
	// For required fields, we always include them.
	data["email"] = m.Email
	if m.IsUsed != nil {
		data["isUsed"] = m.IsUsed
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Invitations) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Invitations) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Invitations) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Invitations) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Invitations) GetUpdated() types.DateTime {
	return m.Updated
}

// IssueComments represents a record from the 'issue_comments' collection.
type IssueComments struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Issue   string          `json:"issue"`
	User    *string         `json:"user",omitempty`
	Content *string         `json:"content",omitempty`
	Images  []string        `json:"images",omitempty`
	MapIds  json.RawMessage `json:"map_ids",omitempty`
	Deleted *types.DateTime `json:"deleted",omitempty`
}

// IssueCommentsCollection is a collection of IssueComments records.
type IssueCommentsCollection struct {
	*pocketbase.ListResult
	Items []*IssueComments `json:"items"`
}

// NewIssueComments creates a new instance of IssueComments.
func NewIssueComments() *IssueComments {
	// Legacy schema initialization
	return &IssueComments{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "issue_comments",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *IssueComments) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["issue"] = m.Issue
	if m.User != nil {
		data["user"] = m.User
	}
	if m.Content != nil {
		data["content"] = m.Content
	}
	if len(m.Images) > 0 {
		data["images"] = m.Images
	}
	// Generic zero-value check
	var zero json.RawMessage
	if m.MapIds != zero {
		data["map_ids"] = m.MapIds
	}
	if m.Deleted != nil {
		data["deleted"] = m.Deleted
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *IssueComments) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *IssueComments) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *IssueComments) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *IssueComments) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *IssueComments) GetUpdated() types.DateTime {
	return m.Updated
}

// IssueContentLogs represents a record from the 'issue_content_logs' collection.
type IssueContentLogs struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Issue   *string `json:"issue",omitempty`
	User    *string `json:"user",omitempty`
	Content *string `json:"content",omitempty`
}

// IssueContentLogsCollection is a collection of IssueContentLogs records.
type IssueContentLogsCollection struct {
	*pocketbase.ListResult
	Items []*IssueContentLogs `json:"items"`
}

// NewIssueContentLogs creates a new instance of IssueContentLogs.
func NewIssueContentLogs() *IssueContentLogs {
	// Legacy schema initialization
	return &IssueContentLogs{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "issue_content_logs",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *IssueContentLogs) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	if m.Issue != nil {
		data["issue"] = m.Issue
	}
	if m.User != nil {
		data["user"] = m.User
	}
	if m.Content != nil {
		data["content"] = m.Content
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *IssueContentLogs) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *IssueContentLogs) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *IssueContentLogs) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *IssueContentLogs) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *IssueContentLogs) GetUpdated() types.DateTime {
	return m.Updated
}

// IssueFieldsLogs represents a record from the 'issue_fields_logs' collection.
type IssueFieldsLogs struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Issue *string         `json:"issue",omitempty`
	User  *string         `json:"user",omitempty`
	Diffs json.RawMessage `json:"diffs"`
}

// IssueFieldsLogsCollection is a collection of IssueFieldsLogs records.
type IssueFieldsLogsCollection struct {
	*pocketbase.ListResult
	Items []*IssueFieldsLogs `json:"items"`
}

// NewIssueFieldsLogs creates a new instance of IssueFieldsLogs.
func NewIssueFieldsLogs() *IssueFieldsLogs {
	// Legacy schema initialization
	return &IssueFieldsLogs{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "issue_fields_logs",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *IssueFieldsLogs) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	if m.Issue != nil {
		data["issue"] = m.Issue
	}
	if m.User != nil {
		data["user"] = m.User
	}
	// For required fields, we always include them.
	data["diffs"] = m.Diffs

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *IssueFieldsLogs) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *IssueFieldsLogs) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *IssueFieldsLogs) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *IssueFieldsLogs) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *IssueFieldsLogs) GetUpdated() types.DateTime {
	return m.Updated
}

// IssueSchedules represents a record from the 'issue_schedules' collection.
type IssueSchedules struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Issue *string         `json:"issue",omitempty`
	Date  *types.DateTime `json:"date",omitempty`
	Title *string         `json:"title",omitempty`
}

// IssueSchedulesCollection is a collection of IssueSchedules records.
type IssueSchedulesCollection struct {
	*pocketbase.ListResult
	Items []*IssueSchedules `json:"items"`
}

// NewIssueSchedules creates a new instance of IssueSchedules.
func NewIssueSchedules() *IssueSchedules {
	// Legacy schema initialization
	return &IssueSchedules{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "issue_schedules",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *IssueSchedules) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	if m.Issue != nil {
		data["issue"] = m.Issue
	}
	if m.Date != nil {
		data["date"] = m.Date
	}
	if m.Title != nil {
		data["title"] = m.Title
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *IssueSchedules) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *IssueSchedules) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *IssueSchedules) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *IssueSchedules) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *IssueSchedules) GetUpdated() types.DateTime {
	return m.Updated
}

// IssueTags represents a record from the 'issue_tags' collection.
type IssueTags struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Name *string `json:"name",omitempty`
}

// IssueTagsCollection is a collection of IssueTags records.
type IssueTagsCollection struct {
	*pocketbase.ListResult
	Items []*IssueTags `json:"items"`
}

// NewIssueTags creates a new instance of IssueTags.
func NewIssueTags() *IssueTags {
	// Legacy schema initialization
	return &IssueTags{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "issue_tags",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *IssueTags) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	if m.Name != nil {
		data["name"] = m.Name
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *IssueTags) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *IssueTags) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *IssueTags) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *IssueTags) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *IssueTags) GetUpdated() types.DateTime {
	return m.Updated
}

// Issues represents a record from the 'issues' collection.
type Issues struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Plant    string          `json:"plant"`
	Title    string          `json:"title"`
	Content  *string         `json:"content",omitempty`
	Images   []string        `json:"images",omitempty`
	Tags     []string        `json:"tags",omitempty`
	Creator  string          `json:"creator"`
	Assignee *string         `json:"assignee",omitempty`
	Date     *types.DateTime `json:"date",omitempty`
	Resolved *types.DateTime `json:"resolved",omitempty`
	Deleted  *types.DateTime `json:"deleted",omitempty`
	MapIds   json.RawMessage `json:"map_ids",omitempty`
	IsPublic *bool           `json:"isPublic",omitempty`
	IsAllDay *bool           `json:"is_all_day",omitempty`
}

// IssuesCollection is a collection of Issues records.
type IssuesCollection struct {
	*pocketbase.ListResult
	Items []*Issues `json:"items"`
}

// NewIssues creates a new instance of Issues.
func NewIssues() *Issues {
	// Legacy schema initialization
	return &Issues{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "issues",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Issues) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["plant"] = m.Plant
	// For required fields, we always include them.
	data["title"] = m.Title
	if m.Content != nil {
		data["content"] = m.Content
	}
	if len(m.Images) > 0 {
		data["images"] = m.Images
	}
	if len(m.Tags) > 0 {
		data["tags"] = m.Tags
	}
	// For required fields, we always include them.
	data["creator"] = m.Creator
	if m.Assignee != nil {
		data["assignee"] = m.Assignee
	}
	if m.Date != nil {
		data["date"] = m.Date
	}
	if m.Resolved != nil {
		data["resolved"] = m.Resolved
	}
	if m.Deleted != nil {
		data["deleted"] = m.Deleted
	}
	// Generic zero-value check
	var zero json.RawMessage
	if m.MapIds != zero {
		data["map_ids"] = m.MapIds
	}
	if m.IsPublic != nil {
		data["isPublic"] = m.IsPublic
	}
	if m.IsAllDay != nil {
		data["is_all_day"] = m.IsAllDay
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Issues) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Issues) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Issues) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Issues) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Issues) GetUpdated() types.DateTime {
	return m.Updated
}

// Organizations represents a record from the 'organizations' collection.
type Organizations struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Name     string          `json:"name"`
	Owner    string          `json:"owner"`
	Metadata json.RawMessage `json:"metadata",omitempty`
	Logo     *string         `json:"logo",omitempty`
	Icon     *string         `json:"icon",omitempty`
	Parent   *string         `json:"parent",omitempty`
}

// OrganizationsCollection is a collection of Organizations records.
type OrganizationsCollection struct {
	*pocketbase.ListResult
	Items []*Organizations `json:"items"`
}

// NewOrganizations creates a new instance of Organizations.
func NewOrganizations() *Organizations {
	// Legacy schema initialization
	return &Organizations{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "organizations",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Organizations) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["name"] = m.Name
	// For required fields, we always include them.
	data["owner"] = m.Owner
	// Generic zero-value check
	var zero json.RawMessage
	if m.Metadata != zero {
		data["metadata"] = m.Metadata
	}
	if m.Logo != nil {
		data["logo"] = m.Logo
	}
	if m.Icon != nil {
		data["icon"] = m.Icon
	}
	if m.Parent != nil {
		data["parent"] = m.Parent
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Organizations) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Organizations) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Organizations) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Organizations) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Organizations) GetUpdated() types.DateTime {
	return m.Updated
}

// Panelmaps represents a record from the 'panelmaps' collection.
type Panelmaps struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Plant string          `json:"plant"`
	Data  json.RawMessage `json:"data",omitempty`
}

// PanelmapsCollection is a collection of Panelmaps records.
type PanelmapsCollection struct {
	*pocketbase.ListResult
	Items []*Panelmaps `json:"items"`
}

// NewPanelmaps creates a new instance of Panelmaps.
func NewPanelmaps() *Panelmaps {
	// Legacy schema initialization
	return &Panelmaps{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "panelmaps",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Panelmaps) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["plant"] = m.Plant
	// Generic zero-value check
	var zero json.RawMessage
	if m.Data != zero {
		data["data"] = m.Data
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Panelmaps) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Panelmaps) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Panelmaps) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Panelmaps) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Panelmaps) GetUpdated() types.DateTime {
	return m.Updated
}

// Passwords represents a record from the 'passwords' collection.
type Passwords struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Organization string  `json:"organization"`
	Password     *string `json:"password",omitempty`
}

// PasswordsCollection is a collection of Passwords records.
type PasswordsCollection struct {
	*pocketbase.ListResult
	Items []*Passwords `json:"items"`
}

// NewPasswords creates a new instance of Passwords.
func NewPasswords() *Passwords {
	// Legacy schema initialization
	return &Passwords{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "passwords",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Passwords) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["organization"] = m.Organization
	if m.Password != nil {
		data["password"] = m.Password
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Passwords) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Passwords) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Passwords) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Passwords) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Passwords) GetUpdated() types.DateTime {
	return m.Updated
}

// Permissions represents a record from the 'permissions' collection.
type Permissions struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Plant     *string  `json:"plant",omitempty`
	Users     []string `json:"users",omitempty`
	Viewers   []string `json:"viewers",omitempty`
	Temporary []string `json:"temporary",omitempty`
}

// PermissionsCollection is a collection of Permissions records.
type PermissionsCollection struct {
	*pocketbase.ListResult
	Items []*Permissions `json:"items"`
}

// NewPermissions creates a new instance of Permissions.
func NewPermissions() *Permissions {
	// Legacy schema initialization
	return &Permissions{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "permissions",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Permissions) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	if m.Plant != nil {
		data["plant"] = m.Plant
	}
	if len(m.Users) > 0 {
		data["users"] = m.Users
	}
	if len(m.Viewers) > 0 {
		data["viewers"] = m.Viewers
	}
	if len(m.Temporary) > 0 {
		data["temporary"] = m.Temporary
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Permissions) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Permissions) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Permissions) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Permissions) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Permissions) GetUpdated() types.DateTime {
	return m.Updated
}

// Plants represents a record from the 'plants' collection.
type Plants struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Name         string          `json:"name"`
	Metadata     json.RawMessage `json:"metadata",omitempty`
	Organization *string         `json:"organization",omitempty`
	Images       []string        `json:"images",omitempty`
	IsArchive    *bool           `json:"isArchive",omitempty`
	Inherits     []string        `json:"inherits",omitempty`
	RefPlant     *string         `json:"refPlant",omitempty`
	Permission   string          `json:"permission"`
}

// PlantsCollection is a collection of Plants records.
type PlantsCollection struct {
	*pocketbase.ListResult
	Items []*Plants `json:"items"`
}

// NewPlants creates a new instance of Plants.
func NewPlants() *Plants {
	// Legacy schema initialization
	return &Plants{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "plants",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Plants) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["name"] = m.Name
	// Generic zero-value check
	var zero json.RawMessage
	if m.Metadata != zero {
		data["metadata"] = m.Metadata
	}
	if m.Organization != nil {
		data["organization"] = m.Organization
	}
	if len(m.Images) > 0 {
		data["images"] = m.Images
	}
	if m.IsArchive != nil {
		data["isArchive"] = m.IsArchive
	}
	if len(m.Inherits) > 0 {
		data["inherits"] = m.Inherits
	}
	if m.RefPlant != nil {
		data["refPlant"] = m.RefPlant
	}
	// For required fields, we always include them.
	data["permission"] = m.Permission

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Plants) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Plants) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Plants) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Plants) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Plants) GetUpdated() types.DateTime {
	return m.Updated
}

// Reports represents a record from the 'reports' collection.
type Reports struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Organization string         `json:"organization"`
	Plants       []string       `json:"plants"`
	Title        string         `json:"title"`
	File         string         `json:"file"`
	Start        types.DateTime `json:"start"`
	End          types.DateTime `json:"end"`
	Description  *string        `json:"description",omitempty`
	IsArchive    *bool          `json:"isArchive",omitempty`
}

// ReportsCollection is a collection of Reports records.
type ReportsCollection struct {
	*pocketbase.ListResult
	Items []*Reports `json:"items"`
}

// NewReports creates a new instance of Reports.
func NewReports() *Reports {
	// Legacy schema initialization
	return &Reports{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "reports",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Reports) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["organization"] = m.Organization
	// For required fields, we always include them.
	data["plants"] = m.Plants
	// For required fields, we always include them.
	data["title"] = m.Title
	// For required fields, we always include them.
	data["file"] = m.File
	// For required fields, we always include them.
	data["start"] = m.Start
	// For required fields, we always include them.
	data["end"] = m.End
	if m.Description != nil {
		data["description"] = m.Description
	}
	if m.IsArchive != nil {
		data["isArchive"] = m.IsArchive
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Reports) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Reports) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Reports) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *Reports) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *Reports) GetUpdated() types.DateTime {
	return m.Updated
}

// WorkOrders represents a record from the 'work_orders' collection.
type WorkOrders struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Issues []string `json:"issues"`
	Plant  string   `json:"plant"`
	User   *string  `json:"user",omitempty`
}

// WorkOrdersCollection is a collection of WorkOrders records.
type WorkOrdersCollection struct {
	*pocketbase.ListResult
	Items []*WorkOrders `json:"items"`
}

// NewWorkOrders creates a new instance of WorkOrders.
func NewWorkOrders() *WorkOrders {
	// Legacy schema initialization
	return &WorkOrders{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "work_orders",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *WorkOrders) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["issues"] = m.Issues
	// For required fields, we always include them.
	data["plant"] = m.Plant
	if m.User != nil {
		data["user"] = m.User
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *WorkOrders) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *WorkOrders) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *WorkOrders) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *WorkOrders) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *WorkOrders) GetUpdated() types.DateTime {
	return m.Updated
}

// OrgParentMap represents a record from the 'org_parent_map' collection.
type OrgParentMap struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Organization json.RawMessage `json:"organization",omitempty`
	Name         json.RawMessage `json:"name",omitempty`
	Parent       json.RawMessage `json:"parent",omitempty`
}

// OrgParentMapCollection is a collection of OrgParentMap records.
type OrgParentMapCollection struct {
	*pocketbase.ListResult
	Items []*OrgParentMap `json:"items"`
}

// NewOrgParentMap creates a new instance of OrgParentMap.
func NewOrgParentMap() *OrgParentMap {
	// Legacy schema initialization
	return &OrgParentMap{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "org_parent_map",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *OrgParentMap) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// Generic zero-value check
	var zero json.RawMessage
	if m.Organization != zero {
		data["organization"] = m.Organization
	}
	// Generic zero-value check
	var zero json.RawMessage
	if m.Name != zero {
		data["name"] = m.Name
	}
	// Generic zero-value check
	var zero json.RawMessage
	if m.Parent != zero {
		data["parent"] = m.Parent
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *OrgParentMap) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *OrgParentMap) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *OrgParentMap) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *OrgParentMap) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *OrgParentMap) GetUpdated() types.DateTime {
	return m.Updated
}

// PanelmapsViewer represents a record from the 'panelmaps_viewer' collection.
type PanelmapsViewer struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Plant string          `json:"plant"`
	Data  json.RawMessage `json:"data",omitempty`
}

// PanelmapsViewerCollection is a collection of PanelmapsViewer records.
type PanelmapsViewerCollection struct {
	*pocketbase.ListResult
	Items []*PanelmapsViewer `json:"items"`
}

// NewPanelmapsViewer creates a new instance of PanelmapsViewer.
func NewPanelmapsViewer() *PanelmapsViewer {
	// Legacy schema initialization
	return &PanelmapsViewer{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "panelmaps_viewer",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *PanelmapsViewer) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["plant"] = m.Plant
	// Generic zero-value check
	var zero json.RawMessage
	if m.Data != zero {
		data["data"] = m.Data
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *PanelmapsViewer) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *PanelmapsViewer) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *PanelmapsViewer) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *PanelmapsViewer) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *PanelmapsViewer) GetUpdated() types.DateTime {
	return m.Updated
}

// PlantsViewer represents a record from the 'plants_viewer' collection.
type PlantsViewer struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Name         string          `json:"name"`
	Metadata     json.RawMessage `json:"metadata",omitempty`
	Organization *string         `json:"organization",omitempty`
	Images       []string        `json:"images",omitempty`
	RefPlant     *string         `json:"refPlant",omitempty`
}

// PlantsViewerCollection is a collection of PlantsViewer records.
type PlantsViewerCollection struct {
	*pocketbase.ListResult
	Items []*PlantsViewer `json:"items"`
}

// NewPlantsViewer creates a new instance of PlantsViewer.
func NewPlantsViewer() *PlantsViewer {
	// Legacy schema initialization
	return &PlantsViewer{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "plants_viewer",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *PlantsViewer) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["name"] = m.Name
	// Generic zero-value check
	var zero json.RawMessage
	if m.Metadata != zero {
		data["metadata"] = m.Metadata
	}
	if m.Organization != nil {
		data["organization"] = m.Organization
	}
	if len(m.Images) > 0 {
		data["images"] = m.Images
	}
	if m.RefPlant != nil {
		data["refPlant"] = m.RefPlant
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *PlantsViewer) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *PlantsViewer) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *PlantsViewer) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *PlantsViewer) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *PlantsViewer) GetUpdated() types.DateTime {
	return m.Updated
}

// TemporaryPanelmaps represents a record from the 'temporary_panelmaps' collection.
type TemporaryPanelmaps struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Plant string          `json:"plant"`
	Data  json.RawMessage `json:"data",omitempty`
}

// TemporaryPanelmapsCollection is a collection of TemporaryPanelmaps records.
type TemporaryPanelmapsCollection struct {
	*pocketbase.ListResult
	Items []*TemporaryPanelmaps `json:"items"`
}

// NewTemporaryPanelmaps creates a new instance of TemporaryPanelmaps.
func NewTemporaryPanelmaps() *TemporaryPanelmaps {
	// Legacy schema initialization
	return &TemporaryPanelmaps{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "temporary_panelmaps",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *TemporaryPanelmaps) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["plant"] = m.Plant
	// Generic zero-value check
	var zero json.RawMessage
	if m.Data != zero {
		data["data"] = m.Data
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *TemporaryPanelmaps) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *TemporaryPanelmaps) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *TemporaryPanelmaps) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *TemporaryPanelmaps) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *TemporaryPanelmaps) GetUpdated() types.DateTime {
	return m.Updated
}

// TemporaryPlants represents a record from the 'temporary_plants' collection.
type TemporaryPlants struct {
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	Name         string          `json:"name"`
	Metadata     json.RawMessage `json:"metadata",omitempty`
	Organization *string         `json:"organization",omitempty`
	RefPlant     *string         `json:"refPlant",omitempty`
}

// TemporaryPlantsCollection is a collection of TemporaryPlants records.
type TemporaryPlantsCollection struct {
	*pocketbase.ListResult
	Items []*TemporaryPlants `json:"items"`
}

// NewTemporaryPlants creates a new instance of TemporaryPlants.
func NewTemporaryPlants() *TemporaryPlants {
	// Legacy schema initialization
	return &TemporaryPlants{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "temporary_plants",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *TemporaryPlants) ToMap() map[string]any {
	data := make(map[string]any)
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}

	// Field data
	// For required fields, we always include them.
	data["name"] = m.Name
	// Generic zero-value check
	var zero json.RawMessage
	if m.Metadata != zero {
		data["metadata"] = m.Metadata
	}
	if m.Organization != nil {
		data["organization"] = m.Organization
	}
	if m.RefPlant != nil {
		data["refPlant"] = m.RefPlant
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *TemporaryPlants) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *TemporaryPlants) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *TemporaryPlants) GetCollectionName() string {
	return m.CollectionName
}

// GetCreated returns the Created field value (legacy schema)
func (m *TemporaryPlants) GetCreated() types.DateTime {
	return m.Created
}

// GetUpdated returns the Updated field value (legacy schema)
func (m *TemporaryPlants) GetUpdated() types.DateTime {
	return m.Updated
}

// ==============
//  Type-Safe Services
// ==============

// TemporaryAccountsService provides type-safe operations for temporary_accounts collection.
type TemporaryAccountsService struct {
	client *pocketbase.Client
}

// NewTemporaryAccountsService creates a new TemporaryAccountsService.
func NewTemporaryAccountsService(client *pocketbase.Client) *TemporaryAccountsService {
	return &TemporaryAccountsService{client: client}
}

// GetOne fetches a single TemporaryAccounts record by its ID.
func (s *TemporaryAccountsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*TemporaryAccounts, error) {
	path := fmt.Sprintf("/api/collections/temporary_accounts/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record TemporaryAccounts
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch temporary_accounts: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of TemporaryAccounts records.
func (s *TemporaryAccountsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*TemporaryAccountsCollection, error) {
	path := "/api/collections/temporary_accounts/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result TemporaryAccountsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch temporary_accounts list: %w", err)
	}
	return &result, nil
}

// Create creates a new TemporaryAccounts record.
func (s *TemporaryAccountsService) Create(ctx context.Context, record *TemporaryAccounts, opts *pocketbase.WriteOptions) (*TemporaryAccounts, error) {
	path := "/api/collections/temporary_accounts/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result TemporaryAccounts
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create temporary_accounts: %w", err)
	}
	return &result, nil
}

// Update updates an existing TemporaryAccounts record.
func (s *TemporaryAccountsService) Update(ctx context.Context, id string, record *TemporaryAccounts, opts *pocketbase.WriteOptions) (*TemporaryAccounts, error) {
	path := fmt.Sprintf("/api/collections/temporary_accounts/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result TemporaryAccounts
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update temporary_accounts: %w", err)
	}
	return &result, nil
}

// Delete deletes a TemporaryAccounts record by its ID.
func (s *TemporaryAccountsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/temporary_accounts/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete temporary_accounts: %w", err)
	}
	return nil
}

// UsersService provides type-safe operations for users collection.
type UsersService struct {
	client *pocketbase.Client
}

// NewUsersService creates a new UsersService.
func NewUsersService(client *pocketbase.Client) *UsersService {
	return &UsersService{client: client}
}

// GetOne fetches a single Users record by its ID.
func (s *UsersService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Users, error) {
	path := fmt.Sprintf("/api/collections/users/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Users
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch users: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Users records.
func (s *UsersService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*UsersCollection, error) {
	path := "/api/collections/users/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result UsersCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch users list: %w", err)
	}
	return &result, nil
}

// Create creates a new Users record.
func (s *UsersService) Create(ctx context.Context, record *Users, opts *pocketbase.WriteOptions) (*Users, error) {
	path := "/api/collections/users/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Users
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create users: %w", err)
	}
	return &result, nil
}

// Update updates an existing Users record.
func (s *UsersService) Update(ctx context.Context, id string, record *Users, opts *pocketbase.WriteOptions) (*Users, error) {
	path := fmt.Sprintf("/api/collections/users/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Users
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update users: %w", err)
	}
	return &result, nil
}

// Delete deletes a Users record by its ID.
func (s *UsersService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/users/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete users: %w", err)
	}
	return nil
}

// ViewersService provides type-safe operations for viewers collection.
type ViewersService struct {
	client *pocketbase.Client
}

// NewViewersService creates a new ViewersService.
func NewViewersService(client *pocketbase.Client) *ViewersService {
	return &ViewersService{client: client}
}

// GetOne fetches a single Viewers record by its ID.
func (s *ViewersService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Viewers, error) {
	path := fmt.Sprintf("/api/collections/viewers/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Viewers
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch viewers: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Viewers records.
func (s *ViewersService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*ViewersCollection, error) {
	path := "/api/collections/viewers/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result ViewersCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch viewers list: %w", err)
	}
	return &result, nil
}

// Create creates a new Viewers record.
func (s *ViewersService) Create(ctx context.Context, record *Viewers, opts *pocketbase.WriteOptions) (*Viewers, error) {
	path := "/api/collections/viewers/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Viewers
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create viewers: %w", err)
	}
	return &result, nil
}

// Update updates an existing Viewers record.
func (s *ViewersService) Update(ctx context.Context, id string, record *Viewers, opts *pocketbase.WriteOptions) (*Viewers, error) {
	path := fmt.Sprintf("/api/collections/viewers/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Viewers
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update viewers: %w", err)
	}
	return &result, nil
}

// Delete deletes a Viewers record by its ID.
func (s *ViewersService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/viewers/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete viewers: %w", err)
	}
	return nil
}

// CommandHistoryService provides type-safe operations for command_history collection.
type CommandHistoryService struct {
	client *pocketbase.Client
}

// NewCommandHistoryService creates a new CommandHistoryService.
func NewCommandHistoryService(client *pocketbase.Client) *CommandHistoryService {
	return &CommandHistoryService{client: client}
}

// GetOne fetches a single CommandHistory record by its ID.
func (s *CommandHistoryService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*CommandHistory, error) {
	path := fmt.Sprintf("/api/collections/command_history/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record CommandHistory
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch command_history: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of CommandHistory records.
func (s *CommandHistoryService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*CommandHistoryCollection, error) {
	path := "/api/collections/command_history/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result CommandHistoryCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch command_history list: %w", err)
	}
	return &result, nil
}

// Create creates a new CommandHistory record.
func (s *CommandHistoryService) Create(ctx context.Context, record *CommandHistory, opts *pocketbase.WriteOptions) (*CommandHistory, error) {
	path := "/api/collections/command_history/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result CommandHistory
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create command_history: %w", err)
	}
	return &result, nil
}

// Update updates an existing CommandHistory record.
func (s *CommandHistoryService) Update(ctx context.Context, id string, record *CommandHistory, opts *pocketbase.WriteOptions) (*CommandHistory, error) {
	path := fmt.Sprintf("/api/collections/command_history/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result CommandHistory
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update command_history: %w", err)
	}
	return &result, nil
}

// Delete deletes a CommandHistory record by its ID.
func (s *CommandHistoryService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/command_history/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete command_history: %w", err)
	}
	return nil
}

// CommentsService provides type-safe operations for comments collection.
type CommentsService struct {
	client *pocketbase.Client
}

// NewCommentsService creates a new CommentsService.
func NewCommentsService(client *pocketbase.Client) *CommentsService {
	return &CommentsService{client: client}
}

// GetOne fetches a single Comments record by its ID.
func (s *CommentsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Comments, error) {
	path := fmt.Sprintf("/api/collections/comments/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Comments
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch comments: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Comments records.
func (s *CommentsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*CommentsCollection, error) {
	path := "/api/collections/comments/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result CommentsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch comments list: %w", err)
	}
	return &result, nil
}

// Create creates a new Comments record.
func (s *CommentsService) Create(ctx context.Context, record *Comments, opts *pocketbase.WriteOptions) (*Comments, error) {
	path := "/api/collections/comments/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Comments
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create comments: %w", err)
	}
	return &result, nil
}

// Update updates an existing Comments record.
func (s *CommentsService) Update(ctx context.Context, id string, record *Comments, opts *pocketbase.WriteOptions) (*Comments, error) {
	path := fmt.Sprintf("/api/collections/comments/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Comments
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update comments: %w", err)
	}
	return &result, nil
}

// Delete deletes a Comments record by its ID.
func (s *CommentsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/comments/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete comments: %w", err)
	}
	return nil
}

// DashboardService provides type-safe operations for dashboard collection.
type DashboardService struct {
	client *pocketbase.Client
}

// NewDashboardService creates a new DashboardService.
func NewDashboardService(client *pocketbase.Client) *DashboardService {
	return &DashboardService{client: client}
}

// GetOne fetches a single Dashboard record by its ID.
func (s *DashboardService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Dashboard, error) {
	path := fmt.Sprintf("/api/collections/dashboard/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Dashboard
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch dashboard: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Dashboard records.
func (s *DashboardService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*DashboardCollection, error) {
	path := "/api/collections/dashboard/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result DashboardCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch dashboard list: %w", err)
	}
	return &result, nil
}

// Create creates a new Dashboard record.
func (s *DashboardService) Create(ctx context.Context, record *Dashboard, opts *pocketbase.WriteOptions) (*Dashboard, error) {
	path := "/api/collections/dashboard/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Dashboard
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create dashboard: %w", err)
	}
	return &result, nil
}

// Update updates an existing Dashboard record.
func (s *DashboardService) Update(ctx context.Context, id string, record *Dashboard, opts *pocketbase.WriteOptions) (*Dashboard, error) {
	path := fmt.Sprintf("/api/collections/dashboard/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Dashboard
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update dashboard: %w", err)
	}
	return &result, nil
}

// Delete deletes a Dashboard record by its ID.
func (s *DashboardService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/dashboard/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete dashboard: %w", err)
	}
	return nil
}

// DevicesService provides type-safe operations for devices collection.
type DevicesService struct {
	client *pocketbase.Client
}

// NewDevicesService creates a new DevicesService.
func NewDevicesService(client *pocketbase.Client) *DevicesService {
	return &DevicesService{client: client}
}

// GetOne fetches a single Devices record by its ID.
func (s *DevicesService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Devices, error) {
	path := fmt.Sprintf("/api/collections/devices/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Devices
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch devices: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Devices records.
func (s *DevicesService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*DevicesCollection, error) {
	path := "/api/collections/devices/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result DevicesCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch devices list: %w", err)
	}
	return &result, nil
}

// Create creates a new Devices record.
func (s *DevicesService) Create(ctx context.Context, record *Devices, opts *pocketbase.WriteOptions) (*Devices, error) {
	path := "/api/collections/devices/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Devices
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create devices: %w", err)
	}
	return &result, nil
}

// Update updates an existing Devices record.
func (s *DevicesService) Update(ctx context.Context, id string, record *Devices, opts *pocketbase.WriteOptions) (*Devices, error) {
	path := fmt.Sprintf("/api/collections/devices/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Devices
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update devices: %w", err)
	}
	return &result, nil
}

// Delete deletes a Devices record by its ID.
func (s *DevicesService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/devices/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete devices: %w", err)
	}
	return nil
}

// FactoriesService provides type-safe operations for factories collection.
type FactoriesService struct {
	client *pocketbase.Client
}

// NewFactoriesService creates a new FactoriesService.
func NewFactoriesService(client *pocketbase.Client) *FactoriesService {
	return &FactoriesService{client: client}
}

// GetOne fetches a single Factories record by its ID.
func (s *FactoriesService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Factories, error) {
	path := fmt.Sprintf("/api/collections/factories/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Factories
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch factories: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Factories records.
func (s *FactoriesService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*FactoriesCollection, error) {
	path := "/api/collections/factories/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result FactoriesCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch factories list: %w", err)
	}
	return &result, nil
}

// Create creates a new Factories record.
func (s *FactoriesService) Create(ctx context.Context, record *Factories, opts *pocketbase.WriteOptions) (*Factories, error) {
	path := "/api/collections/factories/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Factories
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create factories: %w", err)
	}
	return &result, nil
}

// Update updates an existing Factories record.
func (s *FactoriesService) Update(ctx context.Context, id string, record *Factories, opts *pocketbase.WriteOptions) (*Factories, error) {
	path := fmt.Sprintf("/api/collections/factories/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Factories
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update factories: %w", err)
	}
	return &result, nil
}

// Delete deletes a Factories record by its ID.
func (s *FactoriesService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/factories/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete factories: %w", err)
	}
	return nil
}

// GroupconditionsService provides type-safe operations for groupconditions collection.
type GroupconditionsService struct {
	client *pocketbase.Client
}

// NewGroupconditionsService creates a new GroupconditionsService.
func NewGroupconditionsService(client *pocketbase.Client) *GroupconditionsService {
	return &GroupconditionsService{client: client}
}

// GetOne fetches a single Groupconditions record by its ID.
func (s *GroupconditionsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Groupconditions, error) {
	path := fmt.Sprintf("/api/collections/groupconditions/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Groupconditions
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch groupconditions: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Groupconditions records.
func (s *GroupconditionsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*GroupconditionsCollection, error) {
	path := "/api/collections/groupconditions/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result GroupconditionsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch groupconditions list: %w", err)
	}
	return &result, nil
}

// Create creates a new Groupconditions record.
func (s *GroupconditionsService) Create(ctx context.Context, record *Groupconditions, opts *pocketbase.WriteOptions) (*Groupconditions, error) {
	path := "/api/collections/groupconditions/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Groupconditions
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create groupconditions: %w", err)
	}
	return &result, nil
}

// Update updates an existing Groupconditions record.
func (s *GroupconditionsService) Update(ctx context.Context, id string, record *Groupconditions, opts *pocketbase.WriteOptions) (*Groupconditions, error) {
	path := fmt.Sprintf("/api/collections/groupconditions/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Groupconditions
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update groupconditions: %w", err)
	}
	return &result, nil
}

// Delete deletes a Groupconditions record by its ID.
func (s *GroupconditionsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/groupconditions/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete groupconditions: %w", err)
	}
	return nil
}

// ImagesService provides type-safe operations for images collection.
type ImagesService struct {
	client *pocketbase.Client
}

// NewImagesService creates a new ImagesService.
func NewImagesService(client *pocketbase.Client) *ImagesService {
	return &ImagesService{client: client}
}

// GetOne fetches a single Images record by its ID.
func (s *ImagesService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Images, error) {
	path := fmt.Sprintf("/api/collections/images/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Images
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch images: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Images records.
func (s *ImagesService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*ImagesCollection, error) {
	path := "/api/collections/images/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result ImagesCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch images list: %w", err)
	}
	return &result, nil
}

// Create creates a new Images record.
func (s *ImagesService) Create(ctx context.Context, record *Images, opts *pocketbase.WriteOptions) (*Images, error) {
	path := "/api/collections/images/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Images
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create images: %w", err)
	}
	return &result, nil
}

// Update updates an existing Images record.
func (s *ImagesService) Update(ctx context.Context, id string, record *Images, opts *pocketbase.WriteOptions) (*Images, error) {
	path := fmt.Sprintf("/api/collections/images/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Images
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update images: %w", err)
	}
	return &result, nil
}

// Delete deletes a Images record by its ID.
func (s *ImagesService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/images/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete images: %w", err)
	}
	return nil
}

// InvitationsService provides type-safe operations for invitations collection.
type InvitationsService struct {
	client *pocketbase.Client
}

// NewInvitationsService creates a new InvitationsService.
func NewInvitationsService(client *pocketbase.Client) *InvitationsService {
	return &InvitationsService{client: client}
}

// GetOne fetches a single Invitations record by its ID.
func (s *InvitationsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Invitations, error) {
	path := fmt.Sprintf("/api/collections/invitations/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Invitations
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch invitations: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Invitations records.
func (s *InvitationsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*InvitationsCollection, error) {
	path := "/api/collections/invitations/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result InvitationsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch invitations list: %w", err)
	}
	return &result, nil
}

// Create creates a new Invitations record.
func (s *InvitationsService) Create(ctx context.Context, record *Invitations, opts *pocketbase.WriteOptions) (*Invitations, error) {
	path := "/api/collections/invitations/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Invitations
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create invitations: %w", err)
	}
	return &result, nil
}

// Update updates an existing Invitations record.
func (s *InvitationsService) Update(ctx context.Context, id string, record *Invitations, opts *pocketbase.WriteOptions) (*Invitations, error) {
	path := fmt.Sprintf("/api/collections/invitations/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Invitations
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update invitations: %w", err)
	}
	return &result, nil
}

// Delete deletes a Invitations record by its ID.
func (s *InvitationsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/invitations/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete invitations: %w", err)
	}
	return nil
}

// IssueCommentsService provides type-safe operations for issue_comments collection.
type IssueCommentsService struct {
	client *pocketbase.Client
}

// NewIssueCommentsService creates a new IssueCommentsService.
func NewIssueCommentsService(client *pocketbase.Client) *IssueCommentsService {
	return &IssueCommentsService{client: client}
}

// GetOne fetches a single IssueComments record by its ID.
func (s *IssueCommentsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*IssueComments, error) {
	path := fmt.Sprintf("/api/collections/issue_comments/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record IssueComments
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch issue_comments: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of IssueComments records.
func (s *IssueCommentsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*IssueCommentsCollection, error) {
	path := "/api/collections/issue_comments/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueCommentsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch issue_comments list: %w", err)
	}
	return &result, nil
}

// Create creates a new IssueComments record.
func (s *IssueCommentsService) Create(ctx context.Context, record *IssueComments, opts *pocketbase.WriteOptions) (*IssueComments, error) {
	path := "/api/collections/issue_comments/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueComments
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create issue_comments: %w", err)
	}
	return &result, nil
}

// Update updates an existing IssueComments record.
func (s *IssueCommentsService) Update(ctx context.Context, id string, record *IssueComments, opts *pocketbase.WriteOptions) (*IssueComments, error) {
	path := fmt.Sprintf("/api/collections/issue_comments/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueComments
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update issue_comments: %w", err)
	}
	return &result, nil
}

// Delete deletes a IssueComments record by its ID.
func (s *IssueCommentsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/issue_comments/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete issue_comments: %w", err)
	}
	return nil
}

// IssueContentLogsService provides type-safe operations for issue_content_logs collection.
type IssueContentLogsService struct {
	client *pocketbase.Client
}

// NewIssueContentLogsService creates a new IssueContentLogsService.
func NewIssueContentLogsService(client *pocketbase.Client) *IssueContentLogsService {
	return &IssueContentLogsService{client: client}
}

// GetOne fetches a single IssueContentLogs record by its ID.
func (s *IssueContentLogsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*IssueContentLogs, error) {
	path := fmt.Sprintf("/api/collections/issue_content_logs/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record IssueContentLogs
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch issue_content_logs: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of IssueContentLogs records.
func (s *IssueContentLogsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*IssueContentLogsCollection, error) {
	path := "/api/collections/issue_content_logs/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueContentLogsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch issue_content_logs list: %w", err)
	}
	return &result, nil
}

// Create creates a new IssueContentLogs record.
func (s *IssueContentLogsService) Create(ctx context.Context, record *IssueContentLogs, opts *pocketbase.WriteOptions) (*IssueContentLogs, error) {
	path := "/api/collections/issue_content_logs/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueContentLogs
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create issue_content_logs: %w", err)
	}
	return &result, nil
}

// Update updates an existing IssueContentLogs record.
func (s *IssueContentLogsService) Update(ctx context.Context, id string, record *IssueContentLogs, opts *pocketbase.WriteOptions) (*IssueContentLogs, error) {
	path := fmt.Sprintf("/api/collections/issue_content_logs/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueContentLogs
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update issue_content_logs: %w", err)
	}
	return &result, nil
}

// Delete deletes a IssueContentLogs record by its ID.
func (s *IssueContentLogsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/issue_content_logs/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete issue_content_logs: %w", err)
	}
	return nil
}

// IssueFieldsLogsService provides type-safe operations for issue_fields_logs collection.
type IssueFieldsLogsService struct {
	client *pocketbase.Client
}

// NewIssueFieldsLogsService creates a new IssueFieldsLogsService.
func NewIssueFieldsLogsService(client *pocketbase.Client) *IssueFieldsLogsService {
	return &IssueFieldsLogsService{client: client}
}

// GetOne fetches a single IssueFieldsLogs record by its ID.
func (s *IssueFieldsLogsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*IssueFieldsLogs, error) {
	path := fmt.Sprintf("/api/collections/issue_fields_logs/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record IssueFieldsLogs
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch issue_fields_logs: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of IssueFieldsLogs records.
func (s *IssueFieldsLogsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*IssueFieldsLogsCollection, error) {
	path := "/api/collections/issue_fields_logs/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueFieldsLogsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch issue_fields_logs list: %w", err)
	}
	return &result, nil
}

// Create creates a new IssueFieldsLogs record.
func (s *IssueFieldsLogsService) Create(ctx context.Context, record *IssueFieldsLogs, opts *pocketbase.WriteOptions) (*IssueFieldsLogs, error) {
	path := "/api/collections/issue_fields_logs/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueFieldsLogs
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create issue_fields_logs: %w", err)
	}
	return &result, nil
}

// Update updates an existing IssueFieldsLogs record.
func (s *IssueFieldsLogsService) Update(ctx context.Context, id string, record *IssueFieldsLogs, opts *pocketbase.WriteOptions) (*IssueFieldsLogs, error) {
	path := fmt.Sprintf("/api/collections/issue_fields_logs/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueFieldsLogs
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update issue_fields_logs: %w", err)
	}
	return &result, nil
}

// Delete deletes a IssueFieldsLogs record by its ID.
func (s *IssueFieldsLogsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/issue_fields_logs/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete issue_fields_logs: %w", err)
	}
	return nil
}

// IssueSchedulesService provides type-safe operations for issue_schedules collection.
type IssueSchedulesService struct {
	client *pocketbase.Client
}

// NewIssueSchedulesService creates a new IssueSchedulesService.
func NewIssueSchedulesService(client *pocketbase.Client) *IssueSchedulesService {
	return &IssueSchedulesService{client: client}
}

// GetOne fetches a single IssueSchedules record by its ID.
func (s *IssueSchedulesService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*IssueSchedules, error) {
	path := fmt.Sprintf("/api/collections/issue_schedules/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record IssueSchedules
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch issue_schedules: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of IssueSchedules records.
func (s *IssueSchedulesService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*IssueSchedulesCollection, error) {
	path := "/api/collections/issue_schedules/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueSchedulesCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch issue_schedules list: %w", err)
	}
	return &result, nil
}

// Create creates a new IssueSchedules record.
func (s *IssueSchedulesService) Create(ctx context.Context, record *IssueSchedules, opts *pocketbase.WriteOptions) (*IssueSchedules, error) {
	path := "/api/collections/issue_schedules/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueSchedules
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create issue_schedules: %w", err)
	}
	return &result, nil
}

// Update updates an existing IssueSchedules record.
func (s *IssueSchedulesService) Update(ctx context.Context, id string, record *IssueSchedules, opts *pocketbase.WriteOptions) (*IssueSchedules, error) {
	path := fmt.Sprintf("/api/collections/issue_schedules/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueSchedules
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update issue_schedules: %w", err)
	}
	return &result, nil
}

// Delete deletes a IssueSchedules record by its ID.
func (s *IssueSchedulesService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/issue_schedules/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete issue_schedules: %w", err)
	}
	return nil
}

// IssueTagsService provides type-safe operations for issue_tags collection.
type IssueTagsService struct {
	client *pocketbase.Client
}

// NewIssueTagsService creates a new IssueTagsService.
func NewIssueTagsService(client *pocketbase.Client) *IssueTagsService {
	return &IssueTagsService{client: client}
}

// GetOne fetches a single IssueTags record by its ID.
func (s *IssueTagsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*IssueTags, error) {
	path := fmt.Sprintf("/api/collections/issue_tags/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record IssueTags
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch issue_tags: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of IssueTags records.
func (s *IssueTagsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*IssueTagsCollection, error) {
	path := "/api/collections/issue_tags/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueTagsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch issue_tags list: %w", err)
	}
	return &result, nil
}

// Create creates a new IssueTags record.
func (s *IssueTagsService) Create(ctx context.Context, record *IssueTags, opts *pocketbase.WriteOptions) (*IssueTags, error) {
	path := "/api/collections/issue_tags/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueTags
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create issue_tags: %w", err)
	}
	return &result, nil
}

// Update updates an existing IssueTags record.
func (s *IssueTagsService) Update(ctx context.Context, id string, record *IssueTags, opts *pocketbase.WriteOptions) (*IssueTags, error) {
	path := fmt.Sprintf("/api/collections/issue_tags/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssueTags
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update issue_tags: %w", err)
	}
	return &result, nil
}

// Delete deletes a IssueTags record by its ID.
func (s *IssueTagsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/issue_tags/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete issue_tags: %w", err)
	}
	return nil
}

// IssuesService provides type-safe operations for issues collection.
type IssuesService struct {
	client *pocketbase.Client
}

// NewIssuesService creates a new IssuesService.
func NewIssuesService(client *pocketbase.Client) *IssuesService {
	return &IssuesService{client: client}
}

// GetOne fetches a single Issues record by its ID.
func (s *IssuesService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Issues, error) {
	path := fmt.Sprintf("/api/collections/issues/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Issues
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch issues: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Issues records.
func (s *IssuesService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*IssuesCollection, error) {
	path := "/api/collections/issues/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result IssuesCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch issues list: %w", err)
	}
	return &result, nil
}

// Create creates a new Issues record.
func (s *IssuesService) Create(ctx context.Context, record *Issues, opts *pocketbase.WriteOptions) (*Issues, error) {
	path := "/api/collections/issues/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Issues
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create issues: %w", err)
	}
	return &result, nil
}

// Update updates an existing Issues record.
func (s *IssuesService) Update(ctx context.Context, id string, record *Issues, opts *pocketbase.WriteOptions) (*Issues, error) {
	path := fmt.Sprintf("/api/collections/issues/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Issues
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update issues: %w", err)
	}
	return &result, nil
}

// Delete deletes a Issues record by its ID.
func (s *IssuesService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/issues/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete issues: %w", err)
	}
	return nil
}

// OrganizationsService provides type-safe operations for organizations collection.
type OrganizationsService struct {
	client *pocketbase.Client
}

// NewOrganizationsService creates a new OrganizationsService.
func NewOrganizationsService(client *pocketbase.Client) *OrganizationsService {
	return &OrganizationsService{client: client}
}

// GetOne fetches a single Organizations record by its ID.
func (s *OrganizationsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Organizations, error) {
	path := fmt.Sprintf("/api/collections/organizations/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Organizations
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch organizations: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Organizations records.
func (s *OrganizationsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*OrganizationsCollection, error) {
	path := "/api/collections/organizations/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result OrganizationsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch organizations list: %w", err)
	}
	return &result, nil
}

// Create creates a new Organizations record.
func (s *OrganizationsService) Create(ctx context.Context, record *Organizations, opts *pocketbase.WriteOptions) (*Organizations, error) {
	path := "/api/collections/organizations/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Organizations
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create organizations: %w", err)
	}
	return &result, nil
}

// Update updates an existing Organizations record.
func (s *OrganizationsService) Update(ctx context.Context, id string, record *Organizations, opts *pocketbase.WriteOptions) (*Organizations, error) {
	path := fmt.Sprintf("/api/collections/organizations/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Organizations
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update organizations: %w", err)
	}
	return &result, nil
}

// Delete deletes a Organizations record by its ID.
func (s *OrganizationsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/organizations/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete organizations: %w", err)
	}
	return nil
}

// PanelmapsService provides type-safe operations for panelmaps collection.
type PanelmapsService struct {
	client *pocketbase.Client
}

// NewPanelmapsService creates a new PanelmapsService.
func NewPanelmapsService(client *pocketbase.Client) *PanelmapsService {
	return &PanelmapsService{client: client}
}

// GetOne fetches a single Panelmaps record by its ID.
func (s *PanelmapsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Panelmaps, error) {
	path := fmt.Sprintf("/api/collections/panelmaps/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Panelmaps
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch panelmaps: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Panelmaps records.
func (s *PanelmapsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*PanelmapsCollection, error) {
	path := "/api/collections/panelmaps/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result PanelmapsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch panelmaps list: %w", err)
	}
	return &result, nil
}

// Create creates a new Panelmaps record.
func (s *PanelmapsService) Create(ctx context.Context, record *Panelmaps, opts *pocketbase.WriteOptions) (*Panelmaps, error) {
	path := "/api/collections/panelmaps/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Panelmaps
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create panelmaps: %w", err)
	}
	return &result, nil
}

// Update updates an existing Panelmaps record.
func (s *PanelmapsService) Update(ctx context.Context, id string, record *Panelmaps, opts *pocketbase.WriteOptions) (*Panelmaps, error) {
	path := fmt.Sprintf("/api/collections/panelmaps/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Panelmaps
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update panelmaps: %w", err)
	}
	return &result, nil
}

// Delete deletes a Panelmaps record by its ID.
func (s *PanelmapsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/panelmaps/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete panelmaps: %w", err)
	}
	return nil
}

// PasswordsService provides type-safe operations for passwords collection.
type PasswordsService struct {
	client *pocketbase.Client
}

// NewPasswordsService creates a new PasswordsService.
func NewPasswordsService(client *pocketbase.Client) *PasswordsService {
	return &PasswordsService{client: client}
}

// GetOne fetches a single Passwords record by its ID.
func (s *PasswordsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Passwords, error) {
	path := fmt.Sprintf("/api/collections/passwords/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Passwords
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch passwords: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Passwords records.
func (s *PasswordsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*PasswordsCollection, error) {
	path := "/api/collections/passwords/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result PasswordsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch passwords list: %w", err)
	}
	return &result, nil
}

// Create creates a new Passwords record.
func (s *PasswordsService) Create(ctx context.Context, record *Passwords, opts *pocketbase.WriteOptions) (*Passwords, error) {
	path := "/api/collections/passwords/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Passwords
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create passwords: %w", err)
	}
	return &result, nil
}

// Update updates an existing Passwords record.
func (s *PasswordsService) Update(ctx context.Context, id string, record *Passwords, opts *pocketbase.WriteOptions) (*Passwords, error) {
	path := fmt.Sprintf("/api/collections/passwords/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Passwords
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update passwords: %w", err)
	}
	return &result, nil
}

// Delete deletes a Passwords record by its ID.
func (s *PasswordsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/passwords/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete passwords: %w", err)
	}
	return nil
}

// PermissionsService provides type-safe operations for permissions collection.
type PermissionsService struct {
	client *pocketbase.Client
}

// NewPermissionsService creates a new PermissionsService.
func NewPermissionsService(client *pocketbase.Client) *PermissionsService {
	return &PermissionsService{client: client}
}

// GetOne fetches a single Permissions record by its ID.
func (s *PermissionsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Permissions, error) {
	path := fmt.Sprintf("/api/collections/permissions/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Permissions
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch permissions: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Permissions records.
func (s *PermissionsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*PermissionsCollection, error) {
	path := "/api/collections/permissions/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result PermissionsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch permissions list: %w", err)
	}
	return &result, nil
}

// Create creates a new Permissions record.
func (s *PermissionsService) Create(ctx context.Context, record *Permissions, opts *pocketbase.WriteOptions) (*Permissions, error) {
	path := "/api/collections/permissions/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Permissions
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create permissions: %w", err)
	}
	return &result, nil
}

// Update updates an existing Permissions record.
func (s *PermissionsService) Update(ctx context.Context, id string, record *Permissions, opts *pocketbase.WriteOptions) (*Permissions, error) {
	path := fmt.Sprintf("/api/collections/permissions/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Permissions
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update permissions: %w", err)
	}
	return &result, nil
}

// Delete deletes a Permissions record by its ID.
func (s *PermissionsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/permissions/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete permissions: %w", err)
	}
	return nil
}

// PlantsService provides type-safe operations for plants collection.
type PlantsService struct {
	client *pocketbase.Client
}

// NewPlantsService creates a new PlantsService.
func NewPlantsService(client *pocketbase.Client) *PlantsService {
	return &PlantsService{client: client}
}

// GetOne fetches a single Plants record by its ID.
func (s *PlantsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Plants, error) {
	path := fmt.Sprintf("/api/collections/plants/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Plants
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch plants: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Plants records.
func (s *PlantsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*PlantsCollection, error) {
	path := "/api/collections/plants/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result PlantsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch plants list: %w", err)
	}
	return &result, nil
}

// Create creates a new Plants record.
func (s *PlantsService) Create(ctx context.Context, record *Plants, opts *pocketbase.WriteOptions) (*Plants, error) {
	path := "/api/collections/plants/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Plants
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create plants: %w", err)
	}
	return &result, nil
}

// Update updates an existing Plants record.
func (s *PlantsService) Update(ctx context.Context, id string, record *Plants, opts *pocketbase.WriteOptions) (*Plants, error) {
	path := fmt.Sprintf("/api/collections/plants/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Plants
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update plants: %w", err)
	}
	return &result, nil
}

// Delete deletes a Plants record by its ID.
func (s *PlantsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/plants/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete plants: %w", err)
	}
	return nil
}

// ReportsService provides type-safe operations for reports collection.
type ReportsService struct {
	client *pocketbase.Client
}

// NewReportsService creates a new ReportsService.
func NewReportsService(client *pocketbase.Client) *ReportsService {
	return &ReportsService{client: client}
}

// GetOne fetches a single Reports record by its ID.
func (s *ReportsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Reports, error) {
	path := fmt.Sprintf("/api/collections/reports/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Reports
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch reports: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Reports records.
func (s *ReportsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*ReportsCollection, error) {
	path := "/api/collections/reports/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result ReportsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch reports list: %w", err)
	}
	return &result, nil
}

// Create creates a new Reports record.
func (s *ReportsService) Create(ctx context.Context, record *Reports, opts *pocketbase.WriteOptions) (*Reports, error) {
	path := "/api/collections/reports/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Reports
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create reports: %w", err)
	}
	return &result, nil
}

// Update updates an existing Reports record.
func (s *ReportsService) Update(ctx context.Context, id string, record *Reports, opts *pocketbase.WriteOptions) (*Reports, error) {
	path := fmt.Sprintf("/api/collections/reports/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Reports
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update reports: %w", err)
	}
	return &result, nil
}

// Delete deletes a Reports record by its ID.
func (s *ReportsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/reports/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete reports: %w", err)
	}
	return nil
}

// WorkOrdersService provides type-safe operations for work_orders collection.
type WorkOrdersService struct {
	client *pocketbase.Client
}

// NewWorkOrdersService creates a new WorkOrdersService.
func NewWorkOrdersService(client *pocketbase.Client) *WorkOrdersService {
	return &WorkOrdersService{client: client}
}

// GetOne fetches a single WorkOrders record by its ID.
func (s *WorkOrdersService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*WorkOrders, error) {
	path := fmt.Sprintf("/api/collections/work_orders/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record WorkOrders
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch work_orders: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of WorkOrders records.
func (s *WorkOrdersService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*WorkOrdersCollection, error) {
	path := "/api/collections/work_orders/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result WorkOrdersCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch work_orders list: %w", err)
	}
	return &result, nil
}

// Create creates a new WorkOrders record.
func (s *WorkOrdersService) Create(ctx context.Context, record *WorkOrders, opts *pocketbase.WriteOptions) (*WorkOrders, error) {
	path := "/api/collections/work_orders/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result WorkOrders
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create work_orders: %w", err)
	}
	return &result, nil
}

// Update updates an existing WorkOrders record.
func (s *WorkOrdersService) Update(ctx context.Context, id string, record *WorkOrders, opts *pocketbase.WriteOptions) (*WorkOrders, error) {
	path := fmt.Sprintf("/api/collections/work_orders/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result WorkOrders
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update work_orders: %w", err)
	}
	return &result, nil
}

// Delete deletes a WorkOrders record by its ID.
func (s *WorkOrdersService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/work_orders/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete work_orders: %w", err)
	}
	return nil
}

// OrgParentMapService provides type-safe operations for org_parent_map collection.
type OrgParentMapService struct {
	client *pocketbase.Client
}

// NewOrgParentMapService creates a new OrgParentMapService.
func NewOrgParentMapService(client *pocketbase.Client) *OrgParentMapService {
	return &OrgParentMapService{client: client}
}

// GetOne fetches a single OrgParentMap record by its ID.
func (s *OrgParentMapService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*OrgParentMap, error) {
	path := fmt.Sprintf("/api/collections/org_parent_map/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record OrgParentMap
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch org_parent_map: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of OrgParentMap records.
func (s *OrgParentMapService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*OrgParentMapCollection, error) {
	path := "/api/collections/org_parent_map/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result OrgParentMapCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch org_parent_map list: %w", err)
	}
	return &result, nil
}

// Create creates a new OrgParentMap record.
func (s *OrgParentMapService) Create(ctx context.Context, record *OrgParentMap, opts *pocketbase.WriteOptions) (*OrgParentMap, error) {
	path := "/api/collections/org_parent_map/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result OrgParentMap
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create org_parent_map: %w", err)
	}
	return &result, nil
}

// Update updates an existing OrgParentMap record.
func (s *OrgParentMapService) Update(ctx context.Context, id string, record *OrgParentMap, opts *pocketbase.WriteOptions) (*OrgParentMap, error) {
	path := fmt.Sprintf("/api/collections/org_parent_map/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result OrgParentMap
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update org_parent_map: %w", err)
	}
	return &result, nil
}

// Delete deletes a OrgParentMap record by its ID.
func (s *OrgParentMapService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/org_parent_map/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete org_parent_map: %w", err)
	}
	return nil
}

// PanelmapsViewerService provides type-safe operations for panelmaps_viewer collection.
type PanelmapsViewerService struct {
	client *pocketbase.Client
}

// NewPanelmapsViewerService creates a new PanelmapsViewerService.
func NewPanelmapsViewerService(client *pocketbase.Client) *PanelmapsViewerService {
	return &PanelmapsViewerService{client: client}
}

// GetOne fetches a single PanelmapsViewer record by its ID.
func (s *PanelmapsViewerService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*PanelmapsViewer, error) {
	path := fmt.Sprintf("/api/collections/panelmaps_viewer/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record PanelmapsViewer
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch panelmaps_viewer: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of PanelmapsViewer records.
func (s *PanelmapsViewerService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*PanelmapsViewerCollection, error) {
	path := "/api/collections/panelmaps_viewer/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result PanelmapsViewerCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch panelmaps_viewer list: %w", err)
	}
	return &result, nil
}

// Create creates a new PanelmapsViewer record.
func (s *PanelmapsViewerService) Create(ctx context.Context, record *PanelmapsViewer, opts *pocketbase.WriteOptions) (*PanelmapsViewer, error) {
	path := "/api/collections/panelmaps_viewer/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result PanelmapsViewer
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create panelmaps_viewer: %w", err)
	}
	return &result, nil
}

// Update updates an existing PanelmapsViewer record.
func (s *PanelmapsViewerService) Update(ctx context.Context, id string, record *PanelmapsViewer, opts *pocketbase.WriteOptions) (*PanelmapsViewer, error) {
	path := fmt.Sprintf("/api/collections/panelmaps_viewer/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result PanelmapsViewer
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update panelmaps_viewer: %w", err)
	}
	return &result, nil
}

// Delete deletes a PanelmapsViewer record by its ID.
func (s *PanelmapsViewerService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/panelmaps_viewer/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete panelmaps_viewer: %w", err)
	}
	return nil
}

// PlantsViewerService provides type-safe operations for plants_viewer collection.
type PlantsViewerService struct {
	client *pocketbase.Client
}

// NewPlantsViewerService creates a new PlantsViewerService.
func NewPlantsViewerService(client *pocketbase.Client) *PlantsViewerService {
	return &PlantsViewerService{client: client}
}

// GetOne fetches a single PlantsViewer record by its ID.
func (s *PlantsViewerService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*PlantsViewer, error) {
	path := fmt.Sprintf("/api/collections/plants_viewer/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record PlantsViewer
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch plants_viewer: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of PlantsViewer records.
func (s *PlantsViewerService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*PlantsViewerCollection, error) {
	path := "/api/collections/plants_viewer/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result PlantsViewerCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch plants_viewer list: %w", err)
	}
	return &result, nil
}

// Create creates a new PlantsViewer record.
func (s *PlantsViewerService) Create(ctx context.Context, record *PlantsViewer, opts *pocketbase.WriteOptions) (*PlantsViewer, error) {
	path := "/api/collections/plants_viewer/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result PlantsViewer
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create plants_viewer: %w", err)
	}
	return &result, nil
}

// Update updates an existing PlantsViewer record.
func (s *PlantsViewerService) Update(ctx context.Context, id string, record *PlantsViewer, opts *pocketbase.WriteOptions) (*PlantsViewer, error) {
	path := fmt.Sprintf("/api/collections/plants_viewer/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result PlantsViewer
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update plants_viewer: %w", err)
	}
	return &result, nil
}

// Delete deletes a PlantsViewer record by its ID.
func (s *PlantsViewerService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/plants_viewer/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete plants_viewer: %w", err)
	}
	return nil
}

// TemporaryPanelmapsService provides type-safe operations for temporary_panelmaps collection.
type TemporaryPanelmapsService struct {
	client *pocketbase.Client
}

// NewTemporaryPanelmapsService creates a new TemporaryPanelmapsService.
func NewTemporaryPanelmapsService(client *pocketbase.Client) *TemporaryPanelmapsService {
	return &TemporaryPanelmapsService{client: client}
}

// GetOne fetches a single TemporaryPanelmaps record by its ID.
func (s *TemporaryPanelmapsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*TemporaryPanelmaps, error) {
	path := fmt.Sprintf("/api/collections/temporary_panelmaps/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record TemporaryPanelmaps
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch temporary_panelmaps: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of TemporaryPanelmaps records.
func (s *TemporaryPanelmapsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*TemporaryPanelmapsCollection, error) {
	path := "/api/collections/temporary_panelmaps/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result TemporaryPanelmapsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch temporary_panelmaps list: %w", err)
	}
	return &result, nil
}

// Create creates a new TemporaryPanelmaps record.
func (s *TemporaryPanelmapsService) Create(ctx context.Context, record *TemporaryPanelmaps, opts *pocketbase.WriteOptions) (*TemporaryPanelmaps, error) {
	path := "/api/collections/temporary_panelmaps/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result TemporaryPanelmaps
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create temporary_panelmaps: %w", err)
	}
	return &result, nil
}

// Update updates an existing TemporaryPanelmaps record.
func (s *TemporaryPanelmapsService) Update(ctx context.Context, id string, record *TemporaryPanelmaps, opts *pocketbase.WriteOptions) (*TemporaryPanelmaps, error) {
	path := fmt.Sprintf("/api/collections/temporary_panelmaps/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result TemporaryPanelmaps
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update temporary_panelmaps: %w", err)
	}
	return &result, nil
}

// Delete deletes a TemporaryPanelmaps record by its ID.
func (s *TemporaryPanelmapsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/temporary_panelmaps/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete temporary_panelmaps: %w", err)
	}
	return nil
}

// TemporaryPlantsService provides type-safe operations for temporary_plants collection.
type TemporaryPlantsService struct {
	client *pocketbase.Client
}

// NewTemporaryPlantsService creates a new TemporaryPlantsService.
func NewTemporaryPlantsService(client *pocketbase.Client) *TemporaryPlantsService {
	return &TemporaryPlantsService{client: client}
}

// GetOne fetches a single TemporaryPlants record by its ID.
func (s *TemporaryPlantsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*TemporaryPlants, error) {
	path := fmt.Sprintf("/api/collections/temporary_plants/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record TemporaryPlants
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch temporary_plants: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of TemporaryPlants records.
func (s *TemporaryPlantsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*TemporaryPlantsCollection, error) {
	path := "/api/collections/temporary_plants/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result TemporaryPlantsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch temporary_plants list: %w", err)
	}
	return &result, nil
}

// Create creates a new TemporaryPlants record.
func (s *TemporaryPlantsService) Create(ctx context.Context, record *TemporaryPlants, opts *pocketbase.WriteOptions) (*TemporaryPlants, error) {
	path := "/api/collections/temporary_plants/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result TemporaryPlants
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create temporary_plants: %w", err)
	}
	return &result, nil
}

// Update updates an existing TemporaryPlants record.
func (s *TemporaryPlantsService) Update(ctx context.Context, id string, record *TemporaryPlants, opts *pocketbase.WriteOptions) (*TemporaryPlants, error) {
	path := fmt.Sprintf("/api/collections/temporary_plants/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result TemporaryPlants
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update temporary_plants: %w", err)
	}
	return &result, nil
}

// Delete deletes a TemporaryPlants record by its ID.
func (s *TemporaryPlantsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/temporary_plants/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete temporary_plants: %w", err)
	}
	return nil
}

// ==============
//  Convenience Functions (Backward Compatibility)
// ==============

// GetTemporaryAccounts fetches a single TemporaryAccounts record by its ID.
// Deprecated: Use TemporaryAccountsService.GetOne instead.
func GetTemporaryAccounts(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*TemporaryAccounts, error) {
	service := NewTemporaryAccountsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetTemporaryAccountsList fetches a list of TemporaryAccounts records.
// Deprecated: Use TemporaryAccountsService.GetList instead.
func GetTemporaryAccountsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*TemporaryAccountsCollection, error) {
	service := NewTemporaryAccountsService(client)
	return service.GetList(context.Background(), opts)
}

// GetUsers fetches a single Users record by its ID.
// Deprecated: Use UsersService.GetOne instead.
func GetUsers(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Users, error) {
	service := NewUsersService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetUsersList fetches a list of Users records.
// Deprecated: Use UsersService.GetList instead.
func GetUsersList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*UsersCollection, error) {
	service := NewUsersService(client)
	return service.GetList(context.Background(), opts)
}

// GetViewers fetches a single Viewers record by its ID.
// Deprecated: Use ViewersService.GetOne instead.
func GetViewers(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Viewers, error) {
	service := NewViewersService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetViewersList fetches a list of Viewers records.
// Deprecated: Use ViewersService.GetList instead.
func GetViewersList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*ViewersCollection, error) {
	service := NewViewersService(client)
	return service.GetList(context.Background(), opts)
}

// GetCommandHistory fetches a single CommandHistory record by its ID.
// Deprecated: Use CommandHistoryService.GetOne instead.
func GetCommandHistory(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*CommandHistory, error) {
	service := NewCommandHistoryService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetCommandHistoryList fetches a list of CommandHistory records.
// Deprecated: Use CommandHistoryService.GetList instead.
func GetCommandHistoryList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*CommandHistoryCollection, error) {
	service := NewCommandHistoryService(client)
	return service.GetList(context.Background(), opts)
}

// GetComments fetches a single Comments record by its ID.
// Deprecated: Use CommentsService.GetOne instead.
func GetComments(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Comments, error) {
	service := NewCommentsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetCommentsList fetches a list of Comments records.
// Deprecated: Use CommentsService.GetList instead.
func GetCommentsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*CommentsCollection, error) {
	service := NewCommentsService(client)
	return service.GetList(context.Background(), opts)
}

// GetDashboard fetches a single Dashboard record by its ID.
// Deprecated: Use DashboardService.GetOne instead.
func GetDashboard(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Dashboard, error) {
	service := NewDashboardService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetDashboardList fetches a list of Dashboard records.
// Deprecated: Use DashboardService.GetList instead.
func GetDashboardList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*DashboardCollection, error) {
	service := NewDashboardService(client)
	return service.GetList(context.Background(), opts)
}

// GetDevices fetches a single Devices record by its ID.
// Deprecated: Use DevicesService.GetOne instead.
func GetDevices(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Devices, error) {
	service := NewDevicesService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetDevicesList fetches a list of Devices records.
// Deprecated: Use DevicesService.GetList instead.
func GetDevicesList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*DevicesCollection, error) {
	service := NewDevicesService(client)
	return service.GetList(context.Background(), opts)
}

// GetFactories fetches a single Factories record by its ID.
// Deprecated: Use FactoriesService.GetOne instead.
func GetFactories(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Factories, error) {
	service := NewFactoriesService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetFactoriesList fetches a list of Factories records.
// Deprecated: Use FactoriesService.GetList instead.
func GetFactoriesList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*FactoriesCollection, error) {
	service := NewFactoriesService(client)
	return service.GetList(context.Background(), opts)
}

// GetGroupconditions fetches a single Groupconditions record by its ID.
// Deprecated: Use GroupconditionsService.GetOne instead.
func GetGroupconditions(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Groupconditions, error) {
	service := NewGroupconditionsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetGroupconditionsList fetches a list of Groupconditions records.
// Deprecated: Use GroupconditionsService.GetList instead.
func GetGroupconditionsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*GroupconditionsCollection, error) {
	service := NewGroupconditionsService(client)
	return service.GetList(context.Background(), opts)
}

// GetImages fetches a single Images record by its ID.
// Deprecated: Use ImagesService.GetOne instead.
func GetImages(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Images, error) {
	service := NewImagesService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetImagesList fetches a list of Images records.
// Deprecated: Use ImagesService.GetList instead.
func GetImagesList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*ImagesCollection, error) {
	service := NewImagesService(client)
	return service.GetList(context.Background(), opts)
}

// GetInvitations fetches a single Invitations record by its ID.
// Deprecated: Use InvitationsService.GetOne instead.
func GetInvitations(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Invitations, error) {
	service := NewInvitationsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetInvitationsList fetches a list of Invitations records.
// Deprecated: Use InvitationsService.GetList instead.
func GetInvitationsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*InvitationsCollection, error) {
	service := NewInvitationsService(client)
	return service.GetList(context.Background(), opts)
}

// GetIssueComments fetches a single IssueComments record by its ID.
// Deprecated: Use IssueCommentsService.GetOne instead.
func GetIssueComments(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*IssueComments, error) {
	service := NewIssueCommentsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetIssueCommentsList fetches a list of IssueComments records.
// Deprecated: Use IssueCommentsService.GetList instead.
func GetIssueCommentsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*IssueCommentsCollection, error) {
	service := NewIssueCommentsService(client)
	return service.GetList(context.Background(), opts)
}

// GetIssueContentLogs fetches a single IssueContentLogs record by its ID.
// Deprecated: Use IssueContentLogsService.GetOne instead.
func GetIssueContentLogs(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*IssueContentLogs, error) {
	service := NewIssueContentLogsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetIssueContentLogsList fetches a list of IssueContentLogs records.
// Deprecated: Use IssueContentLogsService.GetList instead.
func GetIssueContentLogsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*IssueContentLogsCollection, error) {
	service := NewIssueContentLogsService(client)
	return service.GetList(context.Background(), opts)
}

// GetIssueFieldsLogs fetches a single IssueFieldsLogs record by its ID.
// Deprecated: Use IssueFieldsLogsService.GetOne instead.
func GetIssueFieldsLogs(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*IssueFieldsLogs, error) {
	service := NewIssueFieldsLogsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetIssueFieldsLogsList fetches a list of IssueFieldsLogs records.
// Deprecated: Use IssueFieldsLogsService.GetList instead.
func GetIssueFieldsLogsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*IssueFieldsLogsCollection, error) {
	service := NewIssueFieldsLogsService(client)
	return service.GetList(context.Background(), opts)
}

// GetIssueSchedules fetches a single IssueSchedules record by its ID.
// Deprecated: Use IssueSchedulesService.GetOne instead.
func GetIssueSchedules(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*IssueSchedules, error) {
	service := NewIssueSchedulesService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetIssueSchedulesList fetches a list of IssueSchedules records.
// Deprecated: Use IssueSchedulesService.GetList instead.
func GetIssueSchedulesList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*IssueSchedulesCollection, error) {
	service := NewIssueSchedulesService(client)
	return service.GetList(context.Background(), opts)
}

// GetIssueTags fetches a single IssueTags record by its ID.
// Deprecated: Use IssueTagsService.GetOne instead.
func GetIssueTags(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*IssueTags, error) {
	service := NewIssueTagsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetIssueTagsList fetches a list of IssueTags records.
// Deprecated: Use IssueTagsService.GetList instead.
func GetIssueTagsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*IssueTagsCollection, error) {
	service := NewIssueTagsService(client)
	return service.GetList(context.Background(), opts)
}

// GetIssues fetches a single Issues record by its ID.
// Deprecated: Use IssuesService.GetOne instead.
func GetIssues(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Issues, error) {
	service := NewIssuesService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetIssuesList fetches a list of Issues records.
// Deprecated: Use IssuesService.GetList instead.
func GetIssuesList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*IssuesCollection, error) {
	service := NewIssuesService(client)
	return service.GetList(context.Background(), opts)
}

// GetOrganizations fetches a single Organizations record by its ID.
// Deprecated: Use OrganizationsService.GetOne instead.
func GetOrganizations(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Organizations, error) {
	service := NewOrganizationsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetOrganizationsList fetches a list of Organizations records.
// Deprecated: Use OrganizationsService.GetList instead.
func GetOrganizationsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*OrganizationsCollection, error) {
	service := NewOrganizationsService(client)
	return service.GetList(context.Background(), opts)
}

// GetPanelmaps fetches a single Panelmaps record by its ID.
// Deprecated: Use PanelmapsService.GetOne instead.
func GetPanelmaps(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Panelmaps, error) {
	service := NewPanelmapsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetPanelmapsList fetches a list of Panelmaps records.
// Deprecated: Use PanelmapsService.GetList instead.
func GetPanelmapsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*PanelmapsCollection, error) {
	service := NewPanelmapsService(client)
	return service.GetList(context.Background(), opts)
}

// GetPasswords fetches a single Passwords record by its ID.
// Deprecated: Use PasswordsService.GetOne instead.
func GetPasswords(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Passwords, error) {
	service := NewPasswordsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetPasswordsList fetches a list of Passwords records.
// Deprecated: Use PasswordsService.GetList instead.
func GetPasswordsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*PasswordsCollection, error) {
	service := NewPasswordsService(client)
	return service.GetList(context.Background(), opts)
}

// GetPermissions fetches a single Permissions record by its ID.
// Deprecated: Use PermissionsService.GetOne instead.
func GetPermissions(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Permissions, error) {
	service := NewPermissionsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetPermissionsList fetches a list of Permissions records.
// Deprecated: Use PermissionsService.GetList instead.
func GetPermissionsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*PermissionsCollection, error) {
	service := NewPermissionsService(client)
	return service.GetList(context.Background(), opts)
}

// GetPlants fetches a single Plants record by its ID.
// Deprecated: Use PlantsService.GetOne instead.
func GetPlants(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Plants, error) {
	service := NewPlantsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetPlantsList fetches a list of Plants records.
// Deprecated: Use PlantsService.GetList instead.
func GetPlantsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*PlantsCollection, error) {
	service := NewPlantsService(client)
	return service.GetList(context.Background(), opts)
}

// GetReports fetches a single Reports record by its ID.
// Deprecated: Use ReportsService.GetOne instead.
func GetReports(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Reports, error) {
	service := NewReportsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetReportsList fetches a list of Reports records.
// Deprecated: Use ReportsService.GetList instead.
func GetReportsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*ReportsCollection, error) {
	service := NewReportsService(client)
	return service.GetList(context.Background(), opts)
}

// GetWorkOrders fetches a single WorkOrders record by its ID.
// Deprecated: Use WorkOrdersService.GetOne instead.
func GetWorkOrders(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*WorkOrders, error) {
	service := NewWorkOrdersService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetWorkOrdersList fetches a list of WorkOrders records.
// Deprecated: Use WorkOrdersService.GetList instead.
func GetWorkOrdersList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*WorkOrdersCollection, error) {
	service := NewWorkOrdersService(client)
	return service.GetList(context.Background(), opts)
}

// GetOrgParentMap fetches a single OrgParentMap record by its ID.
// Deprecated: Use OrgParentMapService.GetOne instead.
func GetOrgParentMap(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*OrgParentMap, error) {
	service := NewOrgParentMapService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetOrgParentMapList fetches a list of OrgParentMap records.
// Deprecated: Use OrgParentMapService.GetList instead.
func GetOrgParentMapList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*OrgParentMapCollection, error) {
	service := NewOrgParentMapService(client)
	return service.GetList(context.Background(), opts)
}

// GetPanelmapsViewer fetches a single PanelmapsViewer record by its ID.
// Deprecated: Use PanelmapsViewerService.GetOne instead.
func GetPanelmapsViewer(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*PanelmapsViewer, error) {
	service := NewPanelmapsViewerService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetPanelmapsViewerList fetches a list of PanelmapsViewer records.
// Deprecated: Use PanelmapsViewerService.GetList instead.
func GetPanelmapsViewerList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*PanelmapsViewerCollection, error) {
	service := NewPanelmapsViewerService(client)
	return service.GetList(context.Background(), opts)
}

// GetPlantsViewer fetches a single PlantsViewer record by its ID.
// Deprecated: Use PlantsViewerService.GetOne instead.
func GetPlantsViewer(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*PlantsViewer, error) {
	service := NewPlantsViewerService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetPlantsViewerList fetches a list of PlantsViewer records.
// Deprecated: Use PlantsViewerService.GetList instead.
func GetPlantsViewerList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*PlantsViewerCollection, error) {
	service := NewPlantsViewerService(client)
	return service.GetList(context.Background(), opts)
}

// GetTemporaryPanelmaps fetches a single TemporaryPanelmaps record by its ID.
// Deprecated: Use TemporaryPanelmapsService.GetOne instead.
func GetTemporaryPanelmaps(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*TemporaryPanelmaps, error) {
	service := NewTemporaryPanelmapsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetTemporaryPanelmapsList fetches a list of TemporaryPanelmaps records.
// Deprecated: Use TemporaryPanelmapsService.GetList instead.
func GetTemporaryPanelmapsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*TemporaryPanelmapsCollection, error) {
	service := NewTemporaryPanelmapsService(client)
	return service.GetList(context.Background(), opts)
}

// GetTemporaryPlants fetches a single TemporaryPlants record by its ID.
// Deprecated: Use TemporaryPlantsService.GetOne instead.
func GetTemporaryPlants(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*TemporaryPlants, error) {
	service := NewTemporaryPlantsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetTemporaryPlantsList fetches a list of TemporaryPlants records.
// Deprecated: Use TemporaryPlantsService.GetList instead.
func GetTemporaryPlantsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*TemporaryPlantsCollection, error) {
	service := NewTemporaryPlantsService(client)
	return service.GetList(context.Background(), opts)
}
