// Code generated by pbc-gen. DO NOT EDIT.
// Any changes will be lost on next generation.

package models

import (
	"context"
	"fmt"
	"net/url"

	"github.com/mrchypark/pocketbase-client"
)

// ==============
//  Collection Types
// ==============

// Posts represents a record from the 'posts' collection.
type Posts struct {
	// Latest schema: BaseModel only
	pocketbase.BaseModel
	Title     string  `json:"title"`
	Content   *string `json:"content",omitempty`
	Published *bool   `json:"published",omitempty`
}

// PostsCollection is a collection of Posts records.
type PostsCollection struct {
	*pocketbase.ListResult
	Items []*Posts `json:"items"`
}

// NewPosts creates a new instance of Posts.
func NewPosts() *Posts {
	// Latest schema initialization
	return &Posts{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "",
			CollectionName: "posts",
		},
	}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *Posts) ToMap() map[string]any {
	data := make(map[string]any)

	// Field data
	// For required fields, we always include them.
	data["title"] = m.Title
	if m.Content != nil {
		data["content"] = m.Content
	}
	if m.Published != nil {
		data["published"] = m.Published
	}

	return data
}

// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.

// GetID returns the ID field value
func (m *Posts) GetID() string {
	return m.ID
}

// GetCollectionID returns the CollectionID field value
func (m *Posts) GetCollectionID() string {
	return m.CollectionID
}

// GetCollectionName returns the CollectionName field value
func (m *Posts) GetCollectionName() string {
	return m.CollectionName
}

// ==============
//  Type-Safe Services
// ==============

// PostsService provides type-safe operations for posts collection.
type PostsService struct {
	client *pocketbase.Client
}

// NewPostsService creates a new PostsService.
func NewPostsService(client *pocketbase.Client) *PostsService {
	return &PostsService{client: client}
}

// GetOne fetches a single Posts record by its ID.
func (s *PostsService) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*Posts, error) {
	path := fmt.Sprintf("/api/collections/posts/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record Posts
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch posts: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of Posts records.
func (s *PostsService) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*PostsCollection, error) {
	path := "/api/collections/posts/records"
	q := url.Values{}
	if opts != nil {
		if opts.Page > 0 {
			q.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage > 0 {
			q.Set("perPage", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sort != "" {
			q.Set("sort", opts.Sort)
		}
		if opts.Filter != "" {
			q.Set("filter", opts.Filter)
		}
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
		if opts.SkipTotal {
			q.Set("skipTotal", "1")
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result PostsCollection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch posts list: %w", err)
	}
	return &result, nil
}

// Create creates a new Posts record.
func (s *PostsService) Create(ctx context.Context, record *Posts, opts *pocketbase.WriteOptions) (*Posts, error) {
	path := "/api/collections/posts/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Posts
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create posts: %w", err)
	}
	return &result, nil
}

// Update updates an existing Posts record.
func (s *PostsService) Update(ctx context.Context, id string, record *Posts, opts *pocketbase.WriteOptions) (*Posts, error) {
	path := fmt.Sprintf("/api/collections/posts/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result Posts
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update posts: %w", err)
	}
	return &result, nil
}

// Delete deletes a Posts record by its ID.
func (s *PostsService) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/posts/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete posts: %w", err)
	}
	return nil
}

// ==============
//  Convenience Functions (Backward Compatibility)
// ==============

// GetPosts fetches a single Posts record by its ID.
// Deprecated: Use PostsService.GetOne instead.
func GetPosts(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*Posts, error) {
	service := NewPostsService(client)
	return service.GetOne(context.Background(), id, opts)
}

// GetPostsList fetches a list of Posts records.
// Deprecated: Use PostsService.GetList instead.
func GetPostsList(client *pocketbase.Client, opts *pocketbase.ListOptions) (*PostsCollection, error) {
	service := NewPostsService(client)
	return service.GetList(context.Background(), opts)
}
