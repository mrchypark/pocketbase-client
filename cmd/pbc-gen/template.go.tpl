// Code generated by pbc-gen. DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	{{with .FileTypes}}"fmt"{{end}}

	"github.com/mrchypark/pocketbase-client"
	"github.com/pocketbase/pocketbase/tools/types"
)

var _ = types.DateTime{}

{{with .Enums}}
// ==============
//  Enum Constants
// ==============
{{range .}}
{{$enum := .}}

const (
{{range .Constants}}	{{.Name}} = "{{.Value}}"
{{end}})

func {{$enum.EnumTypeName}}Values() []string {
	return []string{
{{range .Constants}}		{{.Name}},
{{end}}	}
}

func IsValid{{$enum.EnumTypeName}}(value string) bool {
	switch value {
{{range .Constants}}	case {{.Name}}:
		return true
{{end}}	default:
		return false
	}
}
{{end}}
{{end}}

{{with .RelationTypes}}
// ==============
//  Relation Types
// ==============
{{range .}}
{{$relation := .}}

type {{$relation.TypeName}} struct {
	id string
}

func (r {{$relation.TypeName}}) ID() string {
	return r.id
}

func (r {{$relation.TypeName}}) Load(ctx context.Context, client pocketbase.RecordServiceAPI) (*{{$relation.TargetTypeName}}, error) {
	if r.id == "" {
		return nil, nil
	}
	return Get{{$relation.TargetTypeName}}(client, r.id, nil)
}

func (r {{$relation.TypeName}}) IsEmpty() bool {
	return r.id == ""
}

func New{{$relation.TypeName}}(id string) {{$relation.TypeName}} {
	return {{$relation.TypeName}}{id: id}
}

{{if $relation.IsMulti}}
type {{$relation.TypeName}}s []{{$relation.TypeName}}

func (r {{$relation.TypeName}}s) IDs() []string {
	ids := make([]string, len(r))
	for i, rel := range r {
		ids[i] = rel.ID()
	}
	return ids
}

func (r {{$relation.TypeName}}s) LoadAll(ctx context.Context, client pocketbase.RecordServiceAPI) ([]*{{$relation.TargetTypeName}}, error) {
	if len(r) == 0 {
		return nil, nil
	}

	var results []*{{$relation.TargetTypeName}}
	for _, rel := range r {
		record, err := rel.Load(ctx, client)
		if err != nil {
			return nil, err
		}
		if record != nil {
			results = append(results, record)
		}
	}
	return results, nil
}

func (r {{$relation.TypeName}}s) IsEmpty() bool {
	return len(r) == 0
}
{{end}}
{{end}}
{{end}}

{{with .FileTypes}}
// ==============
//  File Types
// ==============

type FileReference struct {
	filename   string
	recordID   string
	collection string
	fieldName  string
}

func (f FileReference) Filename() string {
	return f.filename
}

func (f FileReference) URL(baseURL string) string {
	if f.filename == "" {
		return ""
	}
	return fmt.Sprintf("%s/api/files/%s/%s/%s", baseURL, f.collection, f.recordID, f.filename)
}

func (f FileReference) ThumbURL(baseURL, thumb string) string {
	if f.filename == "" {
		return ""
	}
	return fmt.Sprintf("%s/api/files/%s/%s/%s?thumb=%s", baseURL, f.collection, f.recordID, f.filename, thumb)
}

func (f FileReference) IsEmpty() bool {
	return f.filename == ""
}

func NewFileReference(filename, recordID, collection, fieldName string) FileReference {
	return FileReference{
		filename:   filename,
		recordID:   recordID,
		collection: collection,
		fieldName:  fieldName,
	}
}

type FileReferences []FileReference

func (f FileReferences) Filenames() []string {
	names := make([]string, len(f))
	for i, file := range f {
		names[i] = file.Filename()
	}
	return names
}

func (f FileReferences) URLs(baseURL string) []string {
	urls := make([]string, len(f))
	for i, file := range f {
		urls[i] = file.URL(baseURL)
	}
	return urls
}

func (f FileReferences) ThumbURLs(baseURL, thumb string) []string {
	urls := make([]string, len(f))
	for i, file := range f {
		urls[i] = file.ThumbURL(baseURL, thumb)
	}
	return urls
}

func (f FileReferences) IsEmpty() bool {
	return len(f) == 0
}

func (f FileReferences) Filter() FileReferences {
	var filtered FileReferences
	for _, file := range f {
		if !file.IsEmpty() {
			filtered = append(filtered, file)
		}
	}
	return filtered
}
{{end}}

// ==============
//  Collection Types
// ==============
{{range .Collections}}
{{$collection := .}}

type {{$collection.StructName}} struct {
	ID             string         `json:"id"`
	CollectionID   string         `json:"collectionId"`
	CollectionName string         `json:"collectionName"`
	Created        types.DateTime `json:"created"`
	Updated        types.DateTime `json:"updated"`
	{{range .Fields}}
	{{.GoName}} {{.GoType}} {{.StructTag}}{{end}}
}

var _ pocketbase.RecordModel = (*{{$collection.StructName}})(nil)

func (m *{{$collection.StructName}}) GetID() string             { return m.ID }
func (m *{{$collection.StructName}}) GetCollectionName() string { return "{{$collection.CollectionName}}" }
func (m *{{$collection.StructName}}) SetID(id string)           { m.ID = id }
func (m *{{$collection.StructName}}) SetCollectionID(id string) { m.CollectionID = id }
func (m *{{$collection.StructName}}) SetCollectionName(name string) { m.CollectionName = name }

type {{$collection.StructName}}Collection struct {
	Page       int                      `json:"page"`
	PerPage    int                      `json:"perPage"`
	TotalItems int                      `json:"totalItems"`
	TotalPages int                      `json:"totalPages"`
	Items      []*{{$collection.StructName}} `json:"items"`
}

func New{{$collection.StructName}}() *{{$collection.StructName}} {
	return &{{$collection.StructName}}{CollectionName: "{{$collection.CollectionName}}"}
}
{{range .Fields}}
{{- if .IsPointer}}
func (m *{{$collection.StructName}}) Set{{.GoName}}(v {{.BaseType}}) { m.{{.GoName}} = &v }
{{- else}}
func (m *{{$collection.StructName}}) Set{{.GoName}}(v {{.GoType}}) { m.{{.GoName}} = v }
{{- end}}
{{- end}}

func (m *{{$collection.StructName}}) ToMap() map[string]any {
	data := make(map[string]any)
	{{- range .Fields}}
	{{- if .OmitEmpty}}
	if m.{{.GoName}} != {{if eq .BaseType "string"}}""{{else if eq .BaseType "bool"}}false{{else if eq .BaseType "float64"}}0{{else}}nil{{end}} {
		data["{{.JSONName}}"] = m.{{.GoName}}
	}
	{{- else}}
	data["{{.JSONName}}"] = m.{{.GoName}}
	{{- end}}
	{{- end}}
	return data
}
{{end}}

// ==============
//  Typed Service Factory
// ==============
{{range .Collections}}

func New{{.StructName}}Service(client *pocketbase.Client) *pocketbase.TypedRecordService[{{.StructName}}] {
	return pocketbase.NewTypedRecordService[{{.StructName}}](client, "{{.CollectionName}}")
}
{{end}}

// ==============
//  Typed Helpers
// ==============
{{range .Collections}}

func Get{{.StructName}}(client pocketbase.RecordServiceAPI, id string, opts *pocketbase.GetOneOptions) (*{{.StructName}}, error) {
	r, err := client.GetOne(context.Background(), "{{.CollectionName}}", id, opts)
	if err != nil {
		return nil, err
	}
	result := &{{.StructName}}{}
	result.SetID(r.ID)
	result.SetCollectionID(r.CollectionID)
	result.SetCollectionName(r.CollectionName)
	return result, nil
}

func Get{{.StructName}}List(client pocketbase.RecordServiceAPI, opts *pocketbase.ListOptions) (*{{.StructName}}Collection, error) {
	listResult, err := client.GetList(context.Background(), "{{.CollectionName}}", opts)
	if err != nil {
		return nil, err
	}

	typedItems := make([]*{{.StructName}}, len(listResult.Items))
	for i, r := range listResult.Items {
		item := &{{.StructName}}{}
		item.SetID(r.ID)
		item.SetCollectionID(r.CollectionID)
		item.SetCollectionName(r.CollectionName)
		typedItems[i] = item
	}

	return &{{.StructName}}Collection{
		Page:       listResult.Page,
		PerPage:    listResult.PerPage,
		TotalItems: listResult.TotalItems,
		TotalPages: listResult.TotalPages,
		Items:      typedItems,
	}, nil
}
{{end}}
