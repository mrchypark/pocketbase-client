// Code generated by pbc-gen. DO NOT EDIT.
// Any changes will be lost on next generation.

package {{.PackageName}}

import (
	"context"
	"{{.JsonLibrary}}"

	"github.com/mrchypark/pocketbase-client"
	"github.com/pocketbase/pocketbase/tools/types"
)

// ==============
//  Collection Types
// ==============
{{range .Collections}}
{{$collection := .}}

// {{$collection.StructName}} represents a record from the '{{$collection.CollectionName}}' collection.
type {{$collection.StructName}} struct {
	pocketbase.Record
}

// {{$collection.StructName}}Collection is a collection of {{$collection.StructName}} records.
type {{$collection.StructName}}Collection struct {
	*pocketbase.ListResult
	Items []*{{$collection.StructName}} `json:"items"`
}

// New{{$collection.StructName}} creates a new instance of {{$collection.StructName}}.
func New{{$collection.StructName}}() *{{$collection.StructName}} {
	return &{{$collection.StructName}}{Record: pocketbase.Record{}}
}

// To{{$collection.StructName}} creates a new instance of {{$collection.StructName}} with the provided record.
func To{{$collection.StructName}}(r *pocketbase.Record) *{{$collection.StructName}} {
	return &{{$collection.StructName}}{Record: *r}
}

// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *{{$collection.StructName}}) ToMap() map[string]any {
	data := make(map[string]interface{})

	// non-zero, non-empty, and non-nil values will be added to the map.
	{{- range .Fields}}
	{{- if and .OmitEmpty (ne .GoType "[]string") (ne .GoType "json.RawMessage") (ne .GoType "interface{}") }}
	if val := m.{{.GoName}}(); val != nil {
		data["{{.JsonName}}"] = *val // Dereference pointer
	}
	{{- else if and .OmitEmpty (eq .GoType "[]string") }}
	if val := m.{{.GoName}}(); len(val) > 0 {
		data["{{.JsonName}}"] = val
	}
	{{- else if and .OmitEmpty (eq .GoType "json.RawMessage") }}
	if val := m.{{.GoName}}(); len(val) > 0 && string(val) != "null" {
		data["{{.JsonName}}"] = val
	}
	{{- else if not .OmitEmpty }}
	data["{{.JsonName}}"] = m.{{.GoName}}()
	{{- end}}
	{{- end}}

	return data
}

{{range .Fields}}
// {{.GoName}} returns the value of the '{{.JsonName}}' field.
func (m *{{$collection.StructName}}) {{.GoName}}() {{.GoType}} {
	return m.{{.GetterMethod}}("{{.JsonName}}")
}

// Set{{.GoName}} sets the value of the '{{.JsonName}}' field.
func (m *{{$collection.StructName}}) Set{{.GoName}}(value {{.GoType}}) {
	{{- if and .OmitEmpty (ne .GoType "[]string") (ne .GoType "json.RawMessage") (ne .GoType "interface{}") }}
	if value != nil {
		m.Set("{{.JsonName}}", *value) // ✨ 수정: 포인터를 역참조하여 실제 값을 저장
	} else {
		m.Set("{{.JsonName}}", nil)
	}
	{{- else}}
	m.Set("{{.JsonName}}", value)
	{{- end}}
}
{{end}}
{{end}}

// ==============
//  Typed Helpers
// ==============
{{range .Collections}}

// Get{{.StructName}} fetches a single {{.StructName}} record by its ID.
func Get{{.StructName}}(client pocketbase.RecordServiceAPI, id string, opts *pocketbase.GetOneOptions) (*{{.StructName}}, error) {
	r, err := client.GetOne(context.Background(), "{{.CollectionName}}", id, opts)
	if err != nil {
		return nil, err
	}
	return To{{.StructName}}(r), nil
}

// Get{{.StructName}}List fetches a list of {{.StructName}} records.
func Get{{.StructName}}List(client pocketbase.RecordServiceAPI, opts *pocketbase.ListOptions) (*{{.StructName}}Collection, error) {
	listResult, err := client.GetList(context.Background(), "{{.CollectionName}}", opts)
	if err != nil {
		return nil, err
	}

	typedItems := make([]*{{.StructName}}, len(listResult.Items))
	for i, r := range listResult.Items {
		typedItems[i] = To{{.StructName}}(r)
	}

	return &{{.StructName}}Collection{
		ListResult: listResult,
		Items:      typedItems,
	}, nil
}
{{end}}