// Code generated by pbc-gen. DO NOT EDIT.
// Any changes will be lost on next generation.

package {{.PackageName}}

import (
	"context"
	"fmt"
	"net/url"
	"{{.JSONLibrary}}"

	"github.com/mrchypark/pocketbase-client"
	"github.com/pocketbase/pocketbase/tools/types"
)



{{with .Enums}}
// ==============
//  Enum Constants
// ==============
{{range .}}
{{$enum := .}}

// {{$enum.EnumTypeName}} enum constants for {{$enum.CollectionName}}.{{$enum.FieldName}}
const (
{{range .Constants}}	{{.Name}} = "{{.Value}}"
{{end}})

// {{$enum.EnumTypeName}}Values returns all possible values for {{$enum.EnumTypeName}}
func {{$enum.EnumTypeName}}Values() []string {
	return []string{
{{range .Constants}}		{{.Name}},
{{end}}	}
}

// IsValid{{$enum.EnumTypeName}} checks if the given value is a valid {{$enum.EnumTypeName}}
func IsValid{{$enum.EnumTypeName}}(value string) bool {
	switch value {
{{range .Constants}}	case {{.Name}}:
		return true
{{end}}	default:
		return false
	}
}
{{end}}
{{end}}

{{with .RelationTypes}}
// ==============
//  Relation Types
// ==============
{{range .}}
{{$relation := .}}

// {{$relation.TypeName}} represents a relation to {{$relation.TargetCollection}} collection
type {{$relation.TypeName}} struct {
	id string
}

// ID returns the relation ID
func (r {{$relation.TypeName}}) ID() string {
	return r.id
}

// Load fetches the related {{$relation.TargetTypeName}} record
func (r {{$relation.TypeName}}) Load(ctx context.Context, client *pocketbase.Client) (*{{$relation.TargetTypeName}}, error) {
	if r.id == "" {
		return nil, nil
	}
	return Get{{$relation.TargetTypeName}}(client, r.id, nil)
}

// IsEmpty returns true if the relation is empty
func (r {{$relation.TypeName}}) IsEmpty() bool {
	return r.id == ""
}

// New{{$relation.TypeName}} creates a new {{$relation.TypeName}}
func New{{$relation.TypeName}}(id string) {{$relation.TypeName}} {
	return {{$relation.TypeName}}{id: id}
}

{{if $relation.IsMulti}}
// {{$relation.TypeName}}s represents multiple relations to {{$relation.TargetCollection}} collection
type {{$relation.TypeName}}s []{{$relation.TypeName}}

// IDs returns all relation IDs
func (r {{$relation.TypeName}}s) IDs() []string {
	ids := make([]string, len(r))
	for i, rel := range r {
		ids[i] = rel.ID()
	}
	return ids
}

// LoadAll fetches all related {{$relation.TargetTypeName}} records
func (r {{$relation.TypeName}}s) LoadAll(ctx context.Context, client pocketbase.RecordServiceAPI) ([]*{{$relation.TargetTypeName}}, error) {
	if len(r) == 0 {
		return nil, nil
	}
	
	var results []*{{$relation.TargetTypeName}}
	for _, rel := range r {
		record, err := rel.Load(ctx, client)
		if err != nil {
			return nil, err
		}
		if record != nil {
			results = append(results, record)
		}
	}
	return results, nil
}

// IsEmpty returns true if there are no relations
func (r {{$relation.TypeName}}s) IsEmpty() bool {
	return len(r) == 0
}
{{end}}
{{end}}
{{end}}

{{with .FileTypes}}
// ==============
//  File Types
// ==============

// FileReference represents a file reference
type FileReference struct {
	filename   string
	recordID   string
	collection string
	fieldName  string
}

// Filename returns the filename
func (f FileReference) Filename() string {
	return f.filename
}

// URL generates the file URL
func (f FileReference) URL(baseURL string) string {
	if f.filename == "" {
		return ""
	}
	return fmt.Sprintf("%s/api/files/%s/%s/%s", baseURL, f.collection, f.recordID, f.filename)
}

// ThumbURL generates thumbnail URL
func (f FileReference) ThumbURL(baseURL, thumb string) string {
	if f.filename == "" {
		return ""
	}
	return fmt.Sprintf("%s/api/files/%s/%s/%s?thumb=%s", baseURL, f.collection, f.recordID, f.filename, thumb)
}

// IsEmpty returns true if the file reference is empty
func (f FileReference) IsEmpty() bool {
	return f.filename == ""
}

// NewFileReference creates a new FileReference
func NewFileReference(filename, recordID, collection, fieldName string) FileReference {
	return FileReference{
		filename:   filename,
		recordID:   recordID,
		collection: collection,
		fieldName:  fieldName,
	}
}

// FileReferences represents multiple file references
type FileReferences []FileReference

// Filenames returns all filenames
func (f FileReferences) Filenames() []string {
	names := make([]string, len(f))
	for i, file := range f {
		names[i] = file.Filename()
	}
	return names
}

// URLs generates URLs for all files
func (f FileReferences) URLs(baseURL string) []string {
	urls := make([]string, len(f))
	for i, file := range f {
		urls[i] = file.URL(baseURL)
	}
	return urls
}

// ThumbURLs generates thumbnail URLs for all files
func (f FileReferences) ThumbURLs(baseURL, thumb string) []string {
	urls := make([]string, len(f))
	for i, file := range f {
		urls[i] = file.ThumbURL(baseURL, thumb)
	}
	return urls
}

// IsEmpty returns true if there are no file references
func (f FileReferences) IsEmpty() bool {
	return len(f) == 0
}

// Filter returns non-empty file references
func (f FileReferences) Filter() FileReferences {
	var filtered FileReferences
	for _, file := range f {
		if !file.IsEmpty() {
			filtered = append(filtered, file)
		}
	}
	return filtered
}
{{end}}

// ==============
//  Collection Types
// ==============
{{range .Collections}}
{{$collection := .}}

// {{$collection.StructName}} represents a record from the '{{$collection.CollectionName}}' collection.
type {{$collection.StructName}} struct {
	{{- if eq $collection.SchemaVersion 1}}
	// Legacy schema: BaseModel + BaseDateTime embedding
	pocketbase.BaseModel
	pocketbase.BaseDateTime
	{{- else if eq $collection.SchemaVersion 2}}
	// Latest schema: BaseModel only
	pocketbase.BaseModel
	{{- if $collection.UseTimestamps}}
	// Explicit timestamp fields (when defined in latest schema)
	Created *types.DateTime `json:"created,omitempty"`
	Updated *types.DateTime `json:"updated,omitempty"`
	{{- end}}
	{{- else}}
	// Unknown schema version: fallback to BaseModel only
	pocketbase.BaseModel
	{{- end}}
	{{- range .Fields}}
	{{.GoName}} {{.GoType}} `json:"{{.JSONName}}{{if .OmitEmpty}},omitempty{{end}}"`
	{{- end}}
}

// {{$collection.StructName}}Collection is a collection of {{$collection.StructName}} records.
type {{$collection.StructName}}Collection struct {
	*pocketbase.ListResult
	Items []*{{$collection.StructName}} `json:"items"`
}

// New{{$collection.StructName}} creates a new instance of {{$collection.StructName}}.
func New{{$collection.StructName}}() *{{$collection.StructName}} {
	{{- if eq $collection.SchemaVersion 1}}
	// Legacy schema initialization
	return &{{$collection.StructName}}{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "{{$collection.CollectionID}}",
			CollectionName: "{{$collection.CollectionName}}",
		},
		BaseDateTime: pocketbase.BaseDateTime{
			Created: types.DateTime{},
			Updated: types.DateTime{},
		},
	}
	{{- else if eq $collection.SchemaVersion 2}}
	// Latest schema initialization
	return &{{$collection.StructName}}{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "{{$collection.CollectionID}}",
			CollectionName: "{{$collection.CollectionName}}",
		},
		{{- if $collection.UseTimestamps}}
		Created: nil,
		Updated: nil,
		{{- end}}
	}
	{{- else}}
	// Unknown schema version: fallback to BaseModel only
	return &{{$collection.StructName}}{
		BaseModel: pocketbase.BaseModel{
			ID:             "",
			CollectionID:   "{{$collection.CollectionID}}",
			CollectionName: "{{$collection.CollectionName}}",
		},
	}
	{{- end}}
}






// ToMap converts the struct to a map[string]any for creating/updating records.
// It omits empty or zero-value fields to support PATCH operations.
func (m *{{$collection.StructName}}) ToMap() map[string]any {
	data := make(map[string]any)
    
	{{- if eq $collection.SchemaVersion 1}}
	// Legacy schema: include timestamp fields
	if !m.Created.IsZero() {
		data["created"] = m.Created
	}
	if !m.Updated.IsZero() {
		data["updated"] = m.Updated
	}
	{{- else if eq $collection.SchemaVersion 2}}
	{{- if $collection.UseTimestamps}}
	// Latest schema with explicit timestamps
	if m.Created != nil && !m.Created.IsZero() {
		data["created"] = *m.Created
	}
	if m.Updated != nil && !m.Updated.IsZero() {
		data["updated"] = *m.Updated
	}
	{{- end}}
	{{- end}}
	
	// Field data
	{{- range $i, $field := .Fields}}
	{{- if $field.OmitEmpty}}
	{{- if $field.IsPointer}}
	if m.{{$field.GoName}} != nil {
		data["{{$field.JSONName}}"] = m.{{$field.GoName}}
	}
	{{- else}}
	{{- if eq $field.GoType "string"}}
	if m.{{$field.GoName}} != "" {
		data["{{$field.JSONName}}"] = m.{{$field.GoName}}
	}
	{{- else if eq $field.GoType "bool"}}
	// Always include boolean fields
	data["{{$field.JSONName}}"] = m.{{$field.GoName}}
	{{- else if eq $field.GoType "float64"}}
	if m.{{$field.GoName}} != 0 {
		data["{{$field.JSONName}}"] = m.{{$field.GoName}}
	}
	{{- else if or (eq $field.GoType "[]string") (eq $field.GoType "[]interface{}") (eq $field.GoType "json.RawMessage")}}
	if len(m.{{$field.GoName}}) > 0 {
		data["{{$field.JSONName}}"] = m.{{$field.GoName}}
	}
	{{- else}}
	// Generic zero-value check for {{$field.GoName}}
	{
		var zero{{$i}} {{$field.GoType}}
		if m.{{$field.GoName}} != zero{{$i}} {
			data["{{$field.JSONName}}"] = m.{{$field.GoName}}
		}
	}
	{{- end}}
	{{- end}}
	{{- else}}
	// For required fields, we always include them.
	data["{{$field.JSONName}}"] = m.{{$field.GoName}}
	{{- end}}
    {{- end}}

	return data
}

{{- if or (eq $collection.SchemaVersion 1) (eq $collection.SchemaVersion 2)}}
// For type-safe structs (latest/legacy schema), fields are accessed directly.
// No getter/setter methods are generated as fields are public.
{{- else}}
// For unknown schema version, generate getter/setter methods for compatibility
{{range .Fields}}
// {{.GoName}} returns the value of the '{{.JSONName}}' field.
func (m *{{$collection.StructName}}) {{.GoName}}() {{.GoType}} {
	return m.{{.GetterMethod}}("{{.JSONName}}")
}

{{if .IsPointer}}
// {{.GoName}}ValueOr returns the value of the '{{.JSONName}}' field or the provided default value if nil.
func (m *{{$collection.StructName}}) {{.GoName}}ValueOr(defaultValue {{.BaseType}}) {{.BaseType}} {
	if val := m.{{.GoName}}(); val != nil {
		return *val
	}
	return defaultValue
}
{{end}}

// Set{{.GoName}} sets the value of the '{{.JSONName}}' field.
func (m *{{$collection.StructName}}) Set{{.GoName}}(value {{.GoType}}) {
	m.Set("{{.JSONName}}", value)
}
{{end}}
{{- end}}
{{end}}

{{if .UseGeneric}}
// ==============
//  Service Constructors (Generic)
// ==============
{{range .Collections}}
{{$collection := .}}

// New{{$collection.StructName}}Service creates a new generic service for {{$collection.CollectionName}} collection.
func New{{$collection.StructName}}Service(client *pocketbase.Client) *pocketbase.Service[*{{$collection.StructName}}] {
	return pocketbase.NewService[*{{$collection.StructName}}](
		client,
		"{{$collection.CollectionName}}",
		New{{$collection.StructName}},
	)
}

{{end}}
{{else}}
// ==============
//  Type-Safe Services (Legacy)
// ==============
{{range .Collections}}
{{$collection := .}}

// {{$collection.StructName}}Service provides type-safe operations for {{$collection.CollectionName}} collection.
type {{$collection.StructName}}Service struct {
	client *pocketbase.Client
}

// New{{$collection.StructName}}Service creates a new {{$collection.StructName}}Service.
func New{{$collection.StructName}}Service(client *pocketbase.Client) *{{$collection.StructName}}Service {
	return &{{$collection.StructName}}Service{client: client}
}

// GetOne fetches a single {{$collection.StructName}} record by its ID.
func (s *{{$collection.StructName}}Service) GetOne(ctx context.Context, id string, opts *pocketbase.GetOneOptions) (*{{$collection.StructName}}, error) {
	path := fmt.Sprintf("/api/collections/{{$collection.CollectionName}}/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var record {{$collection.StructName}}
	if err := s.client.Send(ctx, "GET", path, nil, &record); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch {{$collection.CollectionName}}: %w", err)
	}
	return &record, nil
}

// GetList fetches a list of {{$collection.StructName}} records.
func (s *{{$collection.StructName}}Service) GetList(ctx context.Context, opts *pocketbase.ListOptions) (*{{$collection.StructName}}Collection, error) {
	path := "/api/collections/{{$collection.CollectionName}}/records"
	q := url.Values{}
	pocketbase.ApplyListOptions(q, opts)
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result {{$collection.StructName}}Collection
	if err := s.client.Send(ctx, "GET", path, nil, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: fetch {{$collection.CollectionName}} list: %w", err)
	}
	return &result, nil
}

// Create creates a new {{$collection.StructName}} record.
func (s *{{$collection.StructName}}Service) Create(ctx context.Context, record *{{$collection.StructName}}, opts *pocketbase.WriteOptions) (*{{$collection.StructName}}, error) {
	path := "/api/collections/{{$collection.CollectionName}}/records"
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result {{$collection.StructName}}
	if err := s.client.Send(ctx, "POST", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: create {{$collection.CollectionName}}: %w", err)
	}
	return &result, nil
}

// Update updates an existing {{$collection.StructName}} record.
func (s *{{$collection.StructName}}Service) Update(ctx context.Context, id string, record *{{$collection.StructName}}, opts *pocketbase.WriteOptions) (*{{$collection.StructName}}, error) {
	path := fmt.Sprintf("/api/collections/{{$collection.CollectionName}}/records/%s", url.PathEscape(id))
	q := url.Values{}
	if opts != nil {
		if opts.Expand != "" {
			q.Set("expand", opts.Expand)
		}
		if opts.Fields != "" {
			q.Set("fields", opts.Fields)
		}
	}
	if qs := q.Encode(); qs != "" {
		path += "?" + qs
	}

	var result {{$collection.StructName}}
	if err := s.client.Send(ctx, "PATCH", path, record, &result); err != nil {
		return nil, fmt.Errorf("pocketbase: update {{$collection.CollectionName}}: %w", err)
	}
	return &result, nil
}

// Delete deletes a {{$collection.StructName}} record by its ID.
func (s *{{$collection.StructName}}Service) Delete(ctx context.Context, id string) error {
	path := fmt.Sprintf("/api/collections/{{$collection.CollectionName}}/records/%s", url.PathEscape(id))
	if err := s.client.Send(ctx, "DELETE", path, nil, nil); err != nil {
		return fmt.Errorf("pocketbase: delete {{$collection.CollectionName}}: %w", err)
	}
	return nil
}

{{end}}
{{end}}

// ==============
//  Convenience Functions (Backward Compatibility)
// ==============
{{range .Collections}}
{{$collection := .}}

// Get{{$collection.StructName}} fetches a single {{$collection.StructName}} record by its ID.
// Deprecated: Use {{$collection.StructName}}Service.GetOne instead.
func Get{{$collection.StructName}}(client *pocketbase.Client, id string, opts *pocketbase.GetOneOptions) (*{{$collection.StructName}}, error) {
	{{if $.UseGeneric}}
	service := New{{$collection.StructName}}Service(client)
	return service.GetOne(context.Background(), id, opts)
	{{else}}
	service := New{{$collection.StructName}}Service(client)
	return service.GetOne(context.Background(), id, opts)
	{{end}}
}

// Get{{$collection.StructName}}List fetches a list of {{$collection.StructName}} records.
// Deprecated: Use {{$collection.StructName}}Service.GetList instead.
func Get{{$collection.StructName}}List(client *pocketbase.Client, opts *pocketbase.ListOptions) (*{{$collection.StructName}}Collection, error) {
	{{if $.UseGeneric}}
	service := New{{$collection.StructName}}Service(client)
	result, err := service.GetList(context.Background(), opts)
	if err != nil {
		return nil, err
	}
	// Convert generic result to legacy collection format
	return &{{$collection.StructName}}Collection{
		ListResult: result.ListResult,
		Items:      result.Items,
	}, nil
	{{else}}
	service := New{{$collection.StructName}}Service(client)
	return service.GetList(context.Background(), opts)
	{{end}}
}

{{end}}